searchState.loadedDescShard("revmc", 0, "revmc\nAn address.\nAggressive optimizations.\nFunction or parameter attribute.\nThe size of the stack in U256 elements.\nEVM bytecode. Can also be raw EOF code, which will be …\nDefault optimizations.\nAlready-parsed EOF container.\n<code>==</code>.\nContains the error value\nCompilation error.\nEVM bytecode compiler.\nAn EVM bytecode function.\n<code>EvmCompiler</code> input.\nThe EVM bytecode compiler runtime context.\nEVM context stack.\nA native-endian 256-bit unsigned integer, aligned to 8 …\nAssign to the function itself.\nDetermines where on a function an attribute is assigned to.\nExtension trait for <code>Host</code>.\nDefined outside of the module.\nInteger comparison condition.\nLess optimizations.\nLinkage type.\nEVM bytecode compiler linker.\nThe host machine.\nNo optimizations.\n<code>!=</code>.\nContains the success value\nAn opcode and its immediate data. Returned by <code>OpcodesIter</code>.\nOpcode information.\nAn iterator that yields opcodes and their immediate data.\nA bytecode iterator that yields opcodes and their …\nOptimization level.\nAssign to one of the function’s params (0-indexed).\nA pointer to a value.\nThe base of a pointer. Either an address or a stack slot.\nDefined in the module, but not visible outside.\nDefined in the module and visible outside.\nThe raw function signature of a bytecode function.\nCompilation result.\nAssign to the function’s return type.\nThe size of the stack in bytes.\nSize of the return type in bytes.\nSigned <code>&gt;</code>.\nSigned <code>&gt;=</code>.\nSigned <code>&lt;</code>.\nSigned <code>&lt;=</code>.\nA stack slot.\nTail call kind.\nTarget machine.\nLLVM-style target triple.\n<code>Uint</code> for <code>256</code> bits.\nUnsigned <code>&gt;</code>.\nUnsigned <code>&gt;=</code>.\nUnsigned <code>&lt;</code>.\nUnsigned <code>&lt;=</code>.\nThe zero value.\nAdds a function to the module that’s located at <code>address</code>.\nAdds an attribute to a function, one of its parameters, or …\nGets the address of the pointer.\nReturns the stack as a byte array.\nReturns the stack as a byte array.\nReturns the stack as a mutable slice.\nReturns the stack as a slice.\nCasts this value to a <code>U256</code>. This is a no-op on …\nCasts this value to a <code>U256</code>. This is a no-op on …\nThe base of the pointer. Either an address or a stack slot.\nInternal EVM bytecode and opcode representation.\nCalls the function.\nSame as <code>call</code> but with <code>#[inline(never)]</code>.\nCalls the function by re-using the interpreter’s …\nCalls the function by re-using the interpreter’s …\nEVM bytecode compiler implementation.\nContract information and call data.\nDeclare <code>RawEvmCompilerFn</code> functions in an <code>extern &quot;C&quot;</code> block.\nReturns a string representation of the given bytecode.\nFormats an EVM bytecode to the given writer.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConverts an integer from big endian to the target’s …\nCreates a new value from big-endian bytes.\nCreates a new context from an interpreter.\nCreates a stack from the interpreter’s stack. Assumes …\nCreates a new context from an interpreter.\nConverts an integer from little endian to the target’s …\nCreates a new value from little-endian bytes.\nCreates a stack from a mutable pointer.\nCreates a stack from a mutable slice.\nCreates a stack from a mutable vector’s buffer.\nCreates a new value from native-endian bytes.\nCreates a stack from a pointer.\nCreates a stack from a slice.\nConverts a <code>U256</code>.\nConverts a <code>U256</code> mutable reference to a <code>U256</code>.\nConverts a <code>U256</code> reference to a <code>U256</code>.\nCreates a stack from a vector’s buffer.\nThe function stack.\nThe gas.\nThe host.\nSign-extends negative values to <code>ty</code>.\nThe immediate data, if any.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts the pointer to an address.\nUnwraps the function.\nConverts the pointer to a stack slot.\nConverts this value to a <code>U256</code>. This is a no-op on …\nReturns <code>true</code> if the pointer is an address.\nReturns <code>Some(is_value_compile_time)</code>, or <code>None</code> if …\nWhether the context is EOF init.\nReturns <code>true</code> if the pointer is a stack slot.\nWhether the context is static.\nLoads the value from the pointer.\nThe memory.\nReturns the length of the immediate data for the given …\nCreates a new EVM stack, allocated on the stack.\nWraps the function.\nCreates a target from a triple string.\nCreates a new address pointer.\nCreates a vector that can be used as a stack.\nCreates a new stack-allocated pointer.\nThe return action.\nReturns the static info map for the given <code>SpecId</code>.\nThe opcode.\nThe return data.\nReturns the number of input and output stack elements of …\nStores the value to the pointer.\nStores the value to the pointer.\nReverses the byte order of the integer.\nInternal tests and testing utilities. Not public API.\nConverts this value to an <code>Address</code>.\nConverts <code>self</code> to big endian from the target’s endianness.\nReturn the memory representation of this integer as a byte …\nCreates a new interpreter by cloning the context.\nConverts <code>self</code> to little endian from the target’s …\nReturn the memory representation of this integer as a byte …\nReturn the memory representation of this integer as a byte …\nConverts this value to a <code>U256</code>. This is a simple copy on …\nCreates a target from a triple string.\nThe type of the pointee.\nThe target CPU.\nThe target features string.\nThe target triple.\nDon’t generate any code.\nThe instruction is disabled in this EVM version. Always …\nThe instruction is a target of at least one <code>RJUMP*</code> …\nThe instruction is only enabled in EOF bytecodes. Always …\nThe jump target is known to be invalid. Always returns […\nAn EVM instruction is a high level internal representation …\nA single instruction in the bytecode.\n[<code>InstrData</code>] flags.\nSkip generating instruction logic, but keep the gas …\nThe <code>JUMP</code>/<code>JUMPI</code> target is known at compile time. This is …\nNoop opcode used to test suspend-resume.\nThe instruction is unknown. Always returns […\nGet a flags value with all known bits set.\nThe base gas cost of the opcode.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nInstruction-specific data:\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nFlags.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nReturns the length of the immediate data of this …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nReturns <code>true</code> if we know that this instruction will branch …\nReturns <code>true</code> if this instruction is dead code.\nReturns <code>true</code> if we know that this instruction will stop …\nWhether all bits in this flags value are unset.\nReturns <code>true</code> if this instruction is an EOF jump …\nReturns <code>true</code> if this instruction is a jump instruction.\nReturns <code>true</code> if this instruction is a <code>JUMPDEST</code>.\nReturns <code>true</code> if this instruction is a legacy jump …\nReturns <code>true</code> if this instruction is a legacy jump …\nReturns <code>true</code> if this instruction is a push instruction.\nReturns <code>true</code> if this instruction is a reachable <code>JUMPDEST</code>.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nReturns <code>true</code> if this instruction may suspend execution.\nCreates a new instruction data with the given opcode byte. …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe opcode byte.\nThe program counter, meaning <code>code[pc]</code> is this instruction…\nThe intersection of a source flags value with the …\nReturns <code>true</code> if this instruction requires to know <code>gasleft()</code>…\nThe section this instruction belongs to.\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nReturns the number of input and output stack elements of …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nConverts this instruction to a raw opcode. Note that the …\nConverts this instruction to a raw opcode in the given …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe disabled flag.\nThe dynamic flag.\nThe EOF flag.\nThe mask for the gas cost.\nOpcode information.\nThe unknown flag.\nReturns the base gas cost of the opcode.\nReturns <code>true</code> if the opcode is known, but disabled in the …\nReturns <code>true</code> if the gas cost is dynamic.\nReturns <code>true</code> if the opcode is an EOF opcode, meaning it is …\nReturns <code>true</code> if the opcode is unknown.\nCreates a new gas info with the given gas cost.\nReturns the static info map for the given <code>SpecId</code>.\nSets the disabled flag.\nSets the dynamic flag.\nSets the EOF flag.\nSets the gas cost.\nSets the unknown flag.\nAn opcode and its immediate data. Returned by <code>OpcodesIter</code>.\nAn iterator that yields opcodes and their immediate data.\nA bytecode iterator that yields opcodes and their …\nReturns a string representation of the given bytecode.\nFormats an EVM bytecode to the given writer.\nThe immediate data, if any.\nReturns the inner iterator.\nReturns the inner iterator.\nReturns the inner iterator.\nReturns the length of the immediate data for the given …\nCreate a new iterator over the given bytecode slice.\nThe opcode.\nReturns the number of input and output stack elements of …\nReturns a new iterator that also yields the program …\nA section is a sequence of instructions that are executed …\nInstruction section analysis.\nFinishes the analysis.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe total base gas cost of all instructions in the section.\nThe stack height required to execute the section.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the section is empty.\nThe maximum stack height growth relative to the stack …\nProcess a single instruction.\nStarts a new section.\nSaves the current section to the bytecode.\nReturns the current section.\nEVM bytecode. Can also be raw EOF code, which will be …\nAlready-parsed EOF container.\nEVM bytecode compiler.\n<code>EvmCompiler</code> input.\nFrees all functions and resets the state of the internal …\nSets whether to enable debug assertions.\nDumps assembly to the output directory.\nDumps the unoptimized assembly to the output directory.\nSets whether to enable frame pointers.\n(JIT) Frees the memory associated with a single function.\nSets whether to track gas costs.\nSets whether to treat the stack length as observable …\n(JIT) Compiles the given EVM bytecode into a JIT function.\n(JIT) Finalizes the module and JITs the given function.\nSets whether to allocate the stack locally.\nCreates a new instance of the compiler with the given …\nReturns the optimization level.\nReturns the output directory.\nDumps intermediate outputs and other debug info to the …\nSets the name of the module.\nSets the optimization level.\nSets whether to enable stack bound checks.\nEVM to IR translation.\nTranslates the given EVM bytecode into an internal …\nSets whether to validate input EOF containers.\n(AOT) Finalizes the module and writes the compiled object …\n(AOT) Writes the compiled object to the given file.\nUse <code>indirectbr</code>.\nA list of incoming values for a block. Represents a <code>phi</code> …\nUse a switch over <code>0..N</code>.\nA list of <code>switch</code> targets.\nAdds a comment to the current instruction.\nAdds a resume point and returns its index.\nThe backend’s function builder.\nBuilds: <code>fn byte(index: u256, value: u256) -&gt; u256</code>\nBuilds: <code>fn calldataload(index: u256, contract: ptr) -&gt; u256</code>\nBuilds a check, failing if the condition is true.\nBuilds a check, failing if <code>ret</code> is not …\nBuilds a branch to the failure block.\nBuilds a branch to the failure block.\nBuilds:\nBuilds a branch to the return block.\nBuilds a branch to the return block.\nBuilds: <code>fn signextend(ext: u256, x: u256) -&gt; u256</code>\nGets the function for the given builtin.\nBuiltins.\nThe bytecode being translated.\nBuild a call to a builtin.\nBuilds <code>*CALL*</code> instructions.\nBuild a call to a builtin that returns an <code>InstructionResult</code>…\nBuild a call to the panic builtin.\nBuilds a <code>CALLF</code> or <code>JUMPF</code> instruction.\nReturns the spec ID as a value.\nThe contract. Constant throughout the function.\nCreates a named block after the given block.\nCreates a named block after the current block.\nBuilds a <code>CREATE</code> or <code>CREATE2</code> instruction.\nReturns the current block.\nReturns the current instruction.\nThe current instruction being translated.\nDuplicates the <code>n</code>th value from the top of the stack. <code>n</code> …\nThe dynamic jump table block where all dynamic jumps …\nThe EVM context. Opaque pointer, only passed to builtins.\nThe environment. Constant throughout the function.\nExchange two values on the stack. <code>n</code> is the first index, …\nReturns the <code>Eof</code> container, panicking if it is not set.\nBuilds <code>EXT*CALL*</code> instructions.\nThe block that all failures branch to.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nLoads <code>ecx.func_stack</code>.\nBuilds a gas cost deduction for a value.\nBuilds a gas cost deduction for an immediate value.\nThe amount of gas remaining. <code>i64</code>. See <code>Gas</code>.\nGets a field at the given offset.\n<code>dynamic_jump_table</code> incoming values.\n<code>failure_block</code> incoming values.\n<code>return_block</code> incoming values.\nAll entry blocks for each instruction.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGets the stack length before the current instruction.\nStack length before the current instruction.\nStack length offset for the current instruction, used for …\nLoads the gas used.\nLoads the word at the given pointer.\nReturns the block name for the current opcode with the …\nRemoves the topmost element from the stack and returns it.\nRemoves the topmost <code>N</code> elements from the stack and returns …\nPushes a 256-bit value onto the stack.\nPushes 256-bit values onto the stack.\n<code>resume_block</code> switch values.\nThe kind of resume mechanism to use.\nThe return block that all return instructions branch to.\n<code>RETURN</code> or <code>REVERT</code> instruction.\nSaves the local <code>stack_len</code> to <code>stack_len_arg</code>.\nReturns the stack pointer after the input has been popped (…\nReturns the stack pointer at <code>len</code> (<code>&amp;stack[len]</code>).\nReturns the stack pointer at the top (<code>&amp;stack[stack.len]</code>).\nReturns the stack pointer at <code>len</code> from the top (…\nThe stack value. Constant throughout the function, either …\nThe stack length. Either passed in the arguments as a …\nReturns the stack length argument.\nStores the gas used.\nSuspend execution, storing the resume point in the context.\nThe suspend block that all suspend instructions branch to.\n<code>suspend_block</code> incoming values.\nSwaps the topmost value with the <code>n</code>th value from the top. <code>n</code> …\nTranslates an EVM bytecode into a native function.\nfn(data, ptr, len)\nfn(data, ptr, len)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe initial gas limit. This is constant throughout …\nRefunded gas. This is used only at the end of execution.\nThe remaining gas.\nfn(data, ptr, len)\nThe Cranelift-based EVM bytecode compiler backend.\nThe Cranelift-based EVM bytecode compiler function builder.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>Ok(())</code> if the current architecture is supported, …\nCreates a new instance of the JIT compiler.\nVersion number of this crate.\nA prelude providing convenient access to commonly-used …\nImplementation of the <code>InstBuilder</code> that has one convenience …\nTemporary object used to build a single Cranelift IR …\nStructure used for translating a series of functions into …\nUnlike with <code>br_table</code>, <code>Switch</code> cases may be sparse or …\nVersion number of this crate.\nAn opaque reference to a variable.\nBuild the switch\nGet a reference to all existing entries\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe function currently being built. This field is public …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new empty switch\nSet a switch entry\nFunction parameter or return value descriptor.\nAtomicCas(imms=(flags: ir::MemFlags), vals=3, blocks=0)\nAtomicRmw(imms=(flags: ir::MemFlags, op: ir::AtomicRmwOp), …\nFailed float-to-int conversion.\nBinary(imms=(), vals=2, blocks=0)\nBinaryImm64(imms=(imm: ir::immediates::Imm64), vals=1, …\nBinaryImm8(imms=(imm: ir::immediates::Uimm8), vals=1, …\nAn opaque reference to a basic block in a <code>Function</code>.\nBranchTable(imms=(table: ir::JumpTable), vals=1, blocks=0)\nBrif(imms=(), vals=1, blocks=2)\nCall(imms=(func_ref: ir::FuncRef), vals=0, blocks=0)\nCallIndirect(imms=(sig_ref: ir::SigRef), vals=1, blocks=0)\nCondTrap(imms=(code: ir::TrapCode), vals=1, blocks=0)\nA string-based configurator for settings groups.\nValue is a multiple of how many instances of <code>vector_type</code> …\nDynamicStackLoad(imms=(dynamic_stack_slot: …\nDynamicStackStore(imms=(dynamic_stack_slot: …\nA type wrapping a small integer index should implement …\n<code>==</code>.\nEQ\nAn explicit stack slot for dynamic vector types. This is a …\nAn explicit stack slot. This is a chunk of stack memory …\nAn external function.\nThe name of an external is either a reference to a …\nCondition code for comparing floating point numbers.\nFloatCompare(imms=(cond: ir::condcodes::FloatCC), vals=2, …\nFuncAddr(imms=(func_ref: ir::FuncRef), vals=0, blocks=0)\nTemporary object used to build a single Cranelift IR …\nStructure used for translating a series of functions into …\nInformation about a global value declaration.\nGT\nGT | EQ\nA <code>heap_addr</code> instruction detected an out-of-bounds error.\nValue is an offset from another global value.\nAn integer division by zero.\nAn integer arithmetic operation caused an overflow.\nAn IEEE binary32 immediate floating point value, …\nAn IEEE binary64 immediate floating point value, …\n64-bit immediate signed integer operand.\nConvenience methods for building instructions.\nIntAddTrap(imms=(code: ir::TrapCode), vals=2, blocks=0)\nCondition code for comparing integers.\nIntCompare(imms=(cond: ir::condcodes::IntCC), vals=2, …\nIntCompareImm(imms=(cond: ir::condcodes::IntCC, imm: …\nJump(imms=(), vals=0, blocks=1)\nContents of a jump table.\nA well-known symbol.\nLT\nLT | EQ\nA well-known runtime library function.\nLoad(imms=(flags: ir::MemFlags, offset: …\nValue is pointed to by another global value.\nLoadNoOffset(imms=(flags: ir::MemFlags), vals=1, blocks=0)\nFlags for memory operations like load/store.\nMultiAry(imms=(), vals=0, blocks=0)\nThe positive WebAssembly canonical NaN.\nThe positive WebAssembly canonical NaN.\n<code>!=</code>.\nThe C ‘!=’ operator is the inverse of ‘==’: …\nNullAry(imms=(), vals=0, blocks=0)\nEQ | LT | GT\nLT | GT\nThe current stack space was exhausted.\nShuffle(imms=(imm: ir::Immediate), vals=2, blocks=0)\nFunction signature.\nSigned <code>&gt;</code>.\nSigned <code>&gt;=</code>.\nSigned <code>&lt;</code>.\nSigned <code>&lt;=</code>.\nStackLoad(imms=(stack_slot: ir::StackSlot, offset: …\nContents of a stack slot.\nThe kind of a stack slot.\nStackStore(imms=(stack_slot: ir::StackSlot, offset: …\nStore(imms=(flags: ir::MemFlags, offset: …\nStoreNoOffset(imms=(flags: ir::MemFlags), vals=2, blocks=0)\nValue is symbolic, meaning it’s a name which will be …\nTernary(imms=(), vals=3, blocks=0)\nTernaryImm8(imms=(imm: ir::immediates::Uimm8), vals=2, …\nA test case function name of up to a hardcoded amount of …\nTrap(imms=(code: ir::TrapCode), vals=0, blocks=0)\nA trap code describing the reason for a trap.\nThe type of an SSA value.\n64-bit immediate unsigned integer operand.\nUnary(imms=(), vals=1, blocks=0)\nUnaryConst(imms=(constant_handle: ir::Constant), vals=0, …\nUnaryGlobalValue(imms=(global_value: ir::GlobalValue), …\nUnaryIeee16(imms=(imm: ir::immediates::Ieee16), vals=0, …\nUnaryIeee32(imms=(imm: ir::immediates::Ieee32), vals=0, …\nUnaryIeee64(imms=(imm: ir::immediates::Ieee64), vals=0, …\nUnaryImm(imms=(imm: ir::immediates::Imm64), vals=0, …\nUN\nUN | EQ\nUN | GT\nUN | GT | EQ\nUN | LT\nUN | LT | EQ\nUnsigned <code>&gt;</code>.\nUnsigned <code>&gt;=</code>.\nUnsigned <code>&lt;</code>.\nUnsigned <code>&lt;=</code>.\nA reference to a name in a user-defined symbol table.\nValue is the address of the VM context struct.\nAn opaque reference to an SSA value.\nAn opaque reference to a variable.\nComputes the absolute value of <code>self</code>.\nComputes the absolute value of <code>self</code>.\nReads the alias region that this memory operation works …\nAlignment of stack slot as a power-of-two exponent (log2 …\nTest if the <code>aligned</code> flag is set.\nReturns a slice with all possible IntCC values.\nReturns a slice with all possible FloatCC values.\nThe jump table and default block as a single slice. The …\nThe jump table and default block as a single mutable …\nCreates a parameter for a specific <code>Block</code> by appending it …\nAppend parameters to the given <code>Block</code> corresponding to the …\nAppend parameters to the given <code>Block</code> corresponding to the …\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nConverts <code>self</code> to a Rust <code>f32</code>.\nConverts <code>self</code> to a Rust <code>f64</code>.\nGet a type with the same number of lanes as this type, but …\nAccess the jump table as a mutable slice. This excludes …\nReturns the raw byte representing this trap.\nAccess the jump table as a slice. This excludes the …\nGet the type of a comparison result for the given type. …\nGet a type with the same number of lanes as this type, but …\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nPerform an atomic compare-and-swap operation on memory at <code>p</code>…\nAtomically load from memory at <code>p</code>.\nAtomically read-modify-write memory at <code>p</code>, with second …\nAtomically store <code>x</code> to memory at <code>p</code>.\nUnsigned average with rounding: <code>a := (x + y + 1) // 2</code>\nBitwise and.\nBitwise and with immediate.\nBitwise and not.\nReinterpret the bits in <code>x</code> as a different type.\nReverse the bits of a integer.\nReturns the value of this immediate.\nGet the bitwise representation.\nGet the bitwise representation.\nGet the total number of bits used to represent this type.\nConditional select of bits.\nRetrieves all the parameters for a <code>Block</code> currently …\nConvert <code>x</code> to an integer mask.\nBitwise not.\nBitwise or.\nBitwise or with immediate.\nBitwise or not.\nGet the (minimum, maximum) values represented by each lane …\nIndirect branch via jump table.\nConditional branch when cond is non-zero.\nReverse the byte order of an integer.\nBitwise xor.\nBitwise xor with immediate.\nBitwise xor not.\nGet a SIMD vector type with <code>n</code> times more lanes than this …\nGet the number of bytes used to store this type in memory.\nDirect function call.\nCalling convention.\nIndirect function call.\nCalls libc.memcmp\nCalls libc.memcpy\nCalls libc.memmove\nCalls libc.memset\nRound floating point round to integral, towards positive …\nReturns the smallest integer greater than or equal to <code>self</code>.\nReturns the smallest integer greater than or equal to <code>self</code>.\nChanges the destination of a jump instruction after …\nTest if the <code>checked</code> bit is set.\nClear the signature so it is identical to a fresh one …\nClears all entries in this jump table, except for the …\nCount leading sign bits.\nCount leading zero bits.\nWill this function be defined nearby, such that it will …\nReturns a number composed of the magnitude of <code>self</code> and the …\nReturns a number composed of the magnitude of <code>self</code> and the …\nCreates a new <code>Block</code> and returns its reference.\nCreates a dynamic stack slot in the function, to be used by\nDeclares a global value accessible to the function.\nCreates a jump table in the function, to be used by …\nCreates a sized stack slot in the function, to be used by …\nCount trailing zeros.\nGet the block that this builder is currently at.\nReturns a <code>FuncCursor</code> pointed at the current position ready …\nEncodes an assembly debug trap.\nDeclare that the given value is a GC reference that …\nDeclares the type of a variable, panicking if it is …\nDeclare that all uses of the given variable must be …\nRegister a new definition of a user variable. The type of …\nFetch the default block for this jump table.\nMutable access to the default block of this jump table.\nReturns a displayable version of the <code>ExtFuncData</code>, with or …\nReturns a display for the current <code>ExternalName</code>, with extra …\nReturn a value that can display the contents of this jump …\nGet a type with the same number of lanes as this type, but …\nGet the address of a dynamic stack slot.\nLoad a value from a dynamic stack slot.\nStore a value to a dynamic stack slot.\nConvert a dynamic vector type to a fixed one.\nOptimised <code>Self::call_memcmp</code> for small copies.\nOptimised memcpy or memmove for small copies.\nCalls libc.memset\nEnable a boolean setting or apply a preset.\nReturn endianness of the memory access.  This will return …\nMake sure that the current block is inserted in the layout.\nReturn endianness of the memory access, if explicitly …\nMethod for extending argument to a full register.\nReturn a fixed length sub vector, extracted from a dynamic …\nExtract lane <code>Idx</code> from <code>x</code>.\nFloating point constant.\nFloating point constant.\nFloating point constant.\nFloating point constant.\nFloating point absolute value.\nFloating point addition.\nFloating point comparison.\nFloating point copy sign.\nConvert signed integer to floating point.\nConvert unsigned integer to floating point.\nConverts floating point scalars to signed integer.\nCreate an <code>Ieee32</code> number representing the greatest negative …\nCreate an <code>Ieee64</code> number representing the greatest negative …\nConvert floating point to signed integer as fcvt_to_sint …\nConverts floating point scalars to unsigned integer.\nConvert floating point to unsigned integer as fcvt_to_uint …\nConvert <code>x</code> to a smaller floating point format.\nFloating point division.\nA memory fence.  This must provide ordering to ensure …\nDeclare that translation of the current function is …\nRound floating point round to integral, towards negative …\nReturns the largest integer less than or equal to <code>self</code>.\nReturns the largest integer less than or equal to <code>self</code>.\nFloating point fused multiply-and-add.\nFloating point maximum, propagating NaNs using the …\nFloating point minimum, propagating NaNs using the …\nFloating point multiplication.\nFloating point negation.\nConvert <code>x</code> to a larger floating point format.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreates a trap code from its raw byte, likely returned by …\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nFloating point subtraction.\nThe function currently being built. This field is public …\nGet the address of a function.\nConvert <code>x</code> to a smaller floating point format.\nConverts packed single precision floating point to packed …\nGet the address in the frame pointer register.\nGets the content of the pinned register, when it’s …\nGet the PC where this function will transfer control to …\nGet the address in the stack pointer register.\nReturn the type of this global.\nCompute the value of global GV.\nGet a type with the same number of lanes as this type, but …\nInteger absolute value with wrapping: <code>a := |x|</code>.\nWrapping integer addition: <code>a := x + y \\pmod{2^B}</code>.\nAdd immediate integer.\nDoes lane-wise integer pairwise addition on two operands, …\nInteger comparison.\nCompare scalar integer to a constant.\nConcatenate low and high bits to form a larger integer …\nInteger constant.\nDeclare an external function import.\nAdds a signature which can later be used to declare an …\nWrapping integer multiplication: <code>a := x y \\pmod{2^B}</code>.\nInteger multiplication by immediate constant.\nGet the index that was used to create this entity …\nIndex of this type, for use with hash tables etc.\nInteger negation: <code>a := -x \\pmod{2^B}</code>.\nReturns an object with the <code>InstBuilder</code> trait that allows …\nInsert <code>block</code> in the layout <em>after</em> the existing block <code>after</code>.\nInsert <code>y</code> as lane <code>Idx</code> in x.\nReturns the result values of an instruction.\nGet an integer type with the requested number of bits.\nGet an integer type with the requested number of bytes.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert <code>x</code> to a smaller integer type by discarding the most …\nImmediate reverse wrapping subtraction: …\nIs this a SIMD vector type with a runtime number of lanes?\nIs this a scalar floating point type?\nIs this a scalar integer type?\nIs this the INVALID type?\nIs this a lane type?\nDoes this return more than one normal value? (Pre-struct …\nCheck if the value is a NaN. For <code>Ieee32</code>, this means …\nCheck if the value is a NaN. For <code>Ieee64</code>, this means …\nReturns true if <code>self</code> has a negative sign, including -0.0, …\nReturns true if <code>self</code> has a negative sign, including -0.0, …\nReturns true if <code>self</code> has a negative sign, including 0.0, …\nReturns true if <code>self</code> has a negative sign, including 0.0, …\nIs this a special type?\nReturns <code>true</code> if and only if the current <code>Block</code> is sealed …\nIs this a SIMD vector type?\nReturns <code>true</code> if <code>self</code> is positive or negative zero.\nReturns <code>true</code> if <code>self</code> is positive or negative zero.\nInteger shift left. Shift the bits in <code>x</code> towards the MSB by …\nInteger shift left by immediate.\nSplit an integer into low and high parts.\nStore the low 16 bits of <code>x</code> to memory at <code>p + Offset</code>.\nStore the low 32 bits of <code>x</code> to memory at <code>p + Offset</code>.\nStore the low 8 bits of <code>x</code> to memory at <code>p + Offset</code>.\nWrapping integer subtraction: <code>a := x - y \\pmod{2^B}</code>.\nReturns an iterator to the jump table, excluding the …\nReturns an iterator that allows modifying each value, …\nJump.\nThe kind of stack slot.\nGet the number of bits in a lane.\nGet the number of lanes in this SIMD vector type.\nThe type transformation that returns the lane type of a …\nGet the lane type of this SIMD vector type.\nLoad from memory at <code>p + Offset</code>.\nGet log_2 of the number of bits in a lane.\nGet log_2 of the number of lanes in this SIMD vector type.\nGet log_2 of the number of lanes in this vector/dynamic …\nReturns the maximum of <code>self</code> and <code>other</code>, following the …\nReturns the maximum of <code>self</code> and <code>other</code>, following the …\nMerge lanes to half the number of lanes and double the …\nGet the minimum number of bits used to represent this type.\nGet the minimum of lanes in this SIMD vector type, this …\nReturns the minimum of <code>self</code> and <code>other</code>, following the …\nReturns the minimum of <code>self</code> and <code>other</code>, following the …\nName of the external function.\nRound floating point round to integral, towards nearest …\nCreate a new entity reference from a small integer. This …\nCreates a new <code>FunctionBuilder</code> structure that will operate …\nCreates a <code>FunctionBuilderContext</code> structure. The structure …\nCreate a new blank signature.\nCreate a parameter with default flags.\nCreate a new <code>Imm64</code> representing the signed number <code>x</code>.\nCreate a new <code>Uimm64</code> representing the unsigned number <code>x</code>.\nCreate a new jump table with the provided blocks.\nCreate a new empty set of flags.\nCreate a stack slot with the specified byte size and …\nReturns <code>None</code> if <code>self</code> is a NaN and <code>Some(self)</code> otherwise.\nReturns <code>None</code> if <code>self</code> is a NaN and <code>Some(self)</code> otherwise.\nReturns a slice of all traps except <code>TrapCode::User</code> traps\nJust a dummy instruction.\nTest if this memory operation cannot trap.\nHow many special parameters does this function have?\nHow many special returns does this function have?\nThe arguments passed to the function.\nPopulation count\nCreate an <code>Ieee32</code> number representing <code>2.0^n</code>.\nCreate an <code>Ieee64</code> number representing <code>2.0^n</code>.\nSpecial purpose of argument, or <code>Normal</code>.\nTest if the <code>readonly</code> flag is set.\nReturn from the function.\nDirect tail call.\nIndirect tail call.\nValues returned from the function.\nRotate left.\nRotate left by immediate.\nRotate right.\nRotate right by immediate.\nReturns the nearest integer to <code>self</code>. Rounds half-way cases …\nReturns the nearest integer to <code>self</code>. Rounds half-way cases …\nAdd integers signed with overflow out. <code>of</code> is set when the …\nAdd signed integers with carry in and overflow out.\nAdd with signed saturation.\nCopies a scalar value to a vector value.  The scalar is …\nSigned integer division rounded toward zero: …\nSigned integer division by an immediate constant.\nEffectively calls seal_block on all unsealed blocks in the …\nDeclares that all the predecessors of this block are known.\nConditional select.\nConditional select intended for Spectre guards.\nSet the string value of any setting by name.\nSets the alias region that this works on to the specified …\nSet the <code>aligned</code> flag.\nSet a flag bit by name.\nSet the <code>checked</code> bit.\nMark a block as “cold”.\nSet endianness of the memory access.\nSets the trap code for this <code>MemFlags</code> to <code>None</code>.\nSets the content of the pinned register, when it’s …\nSet the <code>readonly</code> flag.\nSet the source location that should be assigned to all new …\nSet label for <code>Value</code>\nConvert <code>self</code> to a parameter type with the <code>sext</code> flag set.\nConvert <code>x</code> to a larger integer type by sign-extending.\nSIMD vector shuffle.\nSign extend this immediate as if it were a signed integer …\nRetrieves the signature with reference <code>sigref</code> previously …\nCall signature of function.\nSize of stack slot in bytes.\nLoad 16 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad a 16x4 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad 32 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad a 32x2 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad 8 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad an 8x8 vector (64 bits) from memory at <code>p + Offset</code> and …\nSigned integer maximum.\nSigned integer minimum.\nMultiply integers signed with overflow out. <code>of</code> is set when …\nSigned integer multiplication, producing the high half of a\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nCreate a special-purpose parameter that is not (yet) bound …\nFind the index of a presumed unique special-purpose …\nFind the index of a presumed unique special-purpose …\nVector splat.\nSplit the lane width in half and double the number of …\nFixed-point multiplication of numbers in the QN format, …\nFloating point square root.\nReturns the square root of <code>self</code>.\nReturns the square root of <code>self</code>.\nSigned integer remainder. The result has the sign of the …\nSigned integer remainder with immediate divisor.\nSigned shift right. Shift bits in <code>x</code> towards the LSB by <code>y</code> …\nSigned shift right by immediate.\nSubtract integers signed with overflow out. <code>of</code> is set when …\nSubtract signed integers with borrow in and overflow out.\nSubtract with signed saturation.\nGet the address of a stack slot.\nLoad a value from a stack slot at the constant offset.\nStore a value to a stack slot at a constant offset.\nSuspends execution of the current stack and resumes …\nStore <code>x</code> to memory at <code>p + Offset</code>.\nWiden the high lanes of <code>x</code> using signed extension.\nWiden the low lanes of <code>x</code> using signed extension.\nAfter the call to this function, new instructions will be …\nVector swizzle.\nAssume that <code>self</code> is an <code>GlobalValueData::Symbol</code> and return …\nCompute the value of global GV, which is a symbolic value.\nCreates a new external name from a sequence of bytes. …\nCompute the value of global GV, which is a TLS (thread …\nGet the corresponding string condition code for the IntCC …\nTerminate execution unconditionally.\nGet the trap code to report if this memory access traps.\nTrap when non-zero.\nTrap when zero.\nReturn the pointer type for the given target triple.\nRound floating point round to integral, towards zero.\nReturns the integer part of <code>self</code>. This means that …\nReturns the integer part of <code>self</code>. This means that …\nCreate a set of flags representing an access from a “…\nDeclares the type of a variable.\nRegisters a new definition of a user variable. This …\nReturns the Cranelift IR necessary to use a previously …\nAdd integers unsigned with overflow out. <code>of</code> is set when …\nAdd unsigned integers with carry in and overflow out.\nUnsigned addition of x and y, trapping if the result …\nAdd with unsigned saturation.\nUnsigned integer division: <code>a := \\lfloor {x \\over y} \\rfloor</code>…\nUnsigned integer division by an immediate constant.\nConvert <code>self</code> to a parameter with the <code>uext</code> flag set.\nConvert <code>x</code> to a larger integer type by zero-extending.\nLoad 16 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad a 16x4 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad 32 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad an 32x2 vector (64 bits) from memory at <code>p + Offset</code> …\nLoad 8 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad an 8x8 vector (64 bits) from memory at <code>p + Offset</code> and …\nUnsigned integer maximum.\nUnsigned integer minimum.\nMultiply integers unsigned with overflow out. <code>of</code> is set …\nUnsigned integer multiplication, producing the high half …\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nGet the corresponding IntCC with the signed component …\nAlias for <code>TrapCode::user</code> with a panic built-in.\nUnsigned integer remainder.\nUnsigned integer remainder with immediate divisor.\nReturns the Cranelift IR value corresponding to the …\nCreate a new external name from a user-defined external …\nCreate a user-defined trap code.\nDoes this signature have a parameter whose <code>ArgumentPurpose</code> …\nDoes this signature have a return whose <code>ArgumentPurpose</code> is …\nDoes this signature take an struct return pointer …\nUnsigned shift right. Shift bits in <code>x</code> towards the LSB by <code>y</code> …\nUnsigned shift right by immediate.\nSubtract integers unsigned with overflow out. <code>of</code> is set …\nSubtract unsigned integers with borrow in and overflow out.\nSubtract with unsigned saturation.\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nWiden the high lanes of <code>x</code> using unsigned extension.\nWiden the low lanes of <code>x</code> using unsigned extension.\nReduce a vector to a scalar boolean.\nType of the argument value.\nReduce a vector to a scalar boolean.\nSIMD vector constant.\nConvert a fixed vector type to a dynamic one.\nReduce a vector to a scalar integer.\nTrue iff:\nSets the alias region that this works on to the specified …\nSet the <code>aligned</code> flag, returning new flags.\nCreate a new <code>Ieee32</code> containing the bits of <code>bits</code>.\nCreate a new <code>Ieee64</code> containing the bits of <code>bits</code>.\nSet the <code>checked</code> bit, returning new flags.\nSet endianness of the memory access, returning new flags.\nCreate a new <code>Ieee32</code> representing the number <code>x</code>.\nCreate a new <code>Ieee64</code> representing the number <code>x</code>.\nSets the trap code for this <code>MemFlags</code> to <code>None</code>, returning …\nCreate a new block reference from its number. This …\nCreate a value from its number representation. This is the …\nSet the <code>readonly</code> flag, returning new flags.\nConfigures these flags with the specified trap code <code>code</code>.\nGet the corresponding IntCC with the equal component …\nReturn self negated.\nReturn self negated.\nA bitselect-lookalike instruction except with the …\nA float-to-integer conversion instruction for …\nAn instruction with equivalent semantics to <code>pmaddubsw</code> on …\nA similar instruction to <code>sqmul_round_sat</code> except with the …\nA vector swizzle lookalike which has the semantics of …\nZero extend this immediate as if it were an unsigned …\nThe base pointer global value.\nThe base pointer global value.\nWill this symbol be defined nearby, such that it will …\nSpecifies the memory flags to be used by the load. …\nType of the loaded value.\nType of the iadd.\nThe symbolic name.\nOffset added to the base pointer before doing the load.\nByte offset to be added to the value.\nOffset from the symbol. This can be used instead of …\nDoes this symbol refer to a thread local storage value?\nBase vector type.\nThe ABI machine spec for this <code>MachInst</code>.\nOffset from the Canonical Frame Address (aka CFA).\nOut-of-line data for calls, to keep the size of <code>Inst</code> down.\nThe code size for the function is too large.\nA compilation error.\nA convenient alias for a <code>Result</code> that uses <code>CodegenError</code> as …\nCompilation error, with the accompanying function to help …\n<code>CompiledCode</code> in its final form (i.e. after …\nPersistent data structures and compilation pipeline.\nContains the error value\nPoints to an ExternalName outside the current function.\nTarget of relocation could be anywhere in the address …\nStatus of a compiled artifact ready to use.\nA relocation resulting from a compilation.\nA Relocation target\nPoints to a CodeOffset from the start of the current …\nA constant value generated during lowering; the value may …\nAn implementation limit was exceeded.\nConstant information used in <code>emit</code> invocations.\nA label-use kind: a type that describes the types of label …\nThe particular location for a value.\nA buffer of output to be produced, fixed up, and then …\nA <code>MachBuffer</code> once emission is completed: holds generated …\nA call site record resulting from a compilation.\nA machine instruction.\nA trait describing the ability to encode a MachInst into …\nA trait describing the emission state carried between …\nA label refers to some offset in a <code>MachBuffer</code>. It may not …\nA source-location mapping resulting from a compilation.\nImplementation of the <code>TextSectionBuilder</code> trait backed by …\nA trap record resulting from a compilation.\nTarget of relocation is “nearby”. The threshold for …\nContains the success value\nRepresents the beginning of an editable region in the …\nA region in the <code>MachBuffer</code> code buffer that can be edited …\nProof-carrying-code validation error.\nA constant already present in the Cranelift IR ConstantPool…\nA real (physical) register. This corresponds to one of the …\nA register named in an instruction. This register can be …\nRegister.\nRegister allocator internal error discovered by the …\nA failure to map Cranelift register representation to a …\nNotion of “relocation distance”. This gives an …\nPersistent state carried across <code>emit</code> invocations.\nByte representation of a trap opcode which is inserted by …\nAn object that can be used to create the text section of …\nA constant of at most 64 bits. These are deduplicated as …\nSomething is not supported by the code generator. This …\nIdentify the different types of constant that can be …\nThis structure tracks the large constants used in VCode …\nVersion number of this crate.\nResulting map of Value labels and their ranges/locations.\nValue location range.\nA list of IR verifier errors.\nA reference to a well-known constant value that is …\nA type wrapper that indicates a register type is writable. …\nAdd a call-site record at the current offset.\nInform the buffer of a conditional branch at the given …\nAdd an external relocation at the current offset.\nAdd an external relocation at the given offset.\nAdd a trap record at the current offset.\nInform the buffer of an unconditional branch at the given …\nAdd an unwind record at the current offset.\nAlign a basic block offset (from start of function).  By …\nAlign up to the given alignment.\nCalculate the alignment of the constant data.\nThe required alignment of this buffer.\nAppends <code>data</code> to the text section with the <code>align</code> specified.\nGet a finalized machine buffer by applying the function’…\nReturn the raw bit encoding for this instance.\nRetrieve the constant data as a byte slice.\nReturn the underlying index value as a <code>u32</code>.\nBind a label to the current offset. A label can only be …\nBinary machine code emission.\nGet the list of call sites for this code.\nThe calling convention of the callee.\nThe number of bytes that the callee will pop from the …\nThe calling convention of the caller.\nGet an appropriate type that can fully hold a value in a …\nPerform NaN canonicalizing rewrites on the function.\nThe control flow graph of <code>func</code>.\nThe <code>CFGPrinter</code> utility.\nGet the class of this register.\nGet the class of this register.\nClear all data structures in this context.\nRegisters clobbered by this call, as per its calling …\nThe trap code.\nCompile the function,\nCompile the function, and emit machine code into a <code>Vec&lt;u8&gt;</code>.\nInternally compiles the function into a stencil.\nReturns the compilation result for this function, …\nCompute the control flow graph.\nCompute dominator tree.\nCompute the loop analysis.\nCreates unwind information for the function.\nThe emission state holds ownership of a control plane, so …\nCurrent offset from start of buffer.\nCursor library.\nGet the code bytes.\nThis module gives users to instantiate values that …\nDebug tracing helpers.\nEmit a trap at some point in the future with the specified …\nRegister defs of this call.\nReceiver of this call\nReturns a display for the current FinalizedRelocTarget, …\nA Dominator Tree represented as mappings of Blocks to …\nDominator tree for <code>func</code>.\nRun optimizations via the egraph infrastructure.\nPerform unreachable code elimination.\nEmit the instruction.\nEmit all pending constants and required pending veneers.\nCreates an empty set of info with no clobbers/uses/etc …\nThe end of the region of code corresponding to a source …\nThe end of the range. It is an offset in the generated …\nEnd a region of patchable code, yielding a <code>PatchRegion</code> …\nMark the end of the <code>SourceLoc</code> segment started at the last …\nCompletes this text section, filling out any final …\nFinish any deferred emissions and/or fixups.\nA control flow graph represented as mappings of basic …\nCompute the control flow graph and dominator tree.\nAllocate a new compilation context with an existing …\nA debug-only option which is used to for\nThe <code>FrameLayout</code> for the function currently being compiled.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new instance from the raw bit encoding.\nGet a label for a block. (The first N MachLabels are …\nExplicitly construct a <code>Writable&lt;T&gt;</code> from a <code>T</code>. As noted in …\nCreate a new instance from a <code>u32</code>.\nThe function we’re compiling.\nFunction we tried to compile, for display purposes.\nReturns a description of the alignment required for …\nGenerate an instruction that must appear at the beginning …\nGenerate a dummy instruction that will keep a value alive …\nGenerate a store of an immediate 64-bit integer to a …\nGenerate a store of an immediate 64-bit integer to a …\nGenerate a jump to another target. Used during lowering of …\nGenerate a move.\nGenerate a NOP. The <code>preferred_size</code> parameter allows the …\nReturns the data associated with the specified constant.\nGet the numeric label index.\nReserve appended space and return a mutable slice …\nIf available, return information about the code layout in …\nAllocate a <code>Label</code> to refer to some offset. May not be bound …\nReturns a label that can be used to refer to the <code>constant</code> …\nReturn the registers referenced by this machine …\nGet a list of source location mapping tuples in …\nThe physical register number.\nUnderlying <code>CodegenError</code> that triggered the error.\nInsert a constant; using this method indicates that a …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRepresentation of Cranelift IR functions.\nIs this an “args” pseudoinst?\nShould this instruction be included in the clobber-set?\nDoes this instruction access memory?\nIf this is a simple move, return the (source, destination) …\nIs this a real (physical) reg?\nIs this a safepoint?\nIs this a terminator (branch or ret)? If so, return its …\nIs this an unconditional trap?\nIs this a virtual reg?\nInstruction Set Architectures.\nIs an island needed within the next N bytes?\nIterate over the <code>VCodeConstant</code> keys and the data (as a …\nIterate over the <code>VCodeConstant</code> keys inserted in this …\nRun the legalizer for <code>isa</code> on the function.\nReturn the number of constants inserted.\nThe source location.\nThe ValueLoc containing a ValueLabel during this range.\nA loop analysis represented as mappings of loops to their …\nLoop analysis of <code>func</code>.\nChange the <code>T</code> payload on this info to <code>U</code>.\nMap the underlying register to another value or type.\nCreate a new emission state given the ABI object.\nCreate a new section, known to start at <code>start_offset</code> and …\nCreates a new text section builder which will have …\nAllocate a new compilation context.\nThe offset at which the trap instruction occurs, <em>relative </em>…\nA hook that triggers when first emitting a new block. It …\nOptimize the function, performing all compilation steps up …\nPerforms various optimizations on branches pointing at the …\nConsume the patch region to yield a mutable slice of the …\nChecks if the given VCodeConstantData is registered as …\nUpdate the emission state before emitting an instruction …\nPretty-print the instruction.\nUtility routines for pretty-printing error messages.\nPush a user stack map onto this buffer.\nAdd a byte.\nAdd 2 bytes.\nAdd 4 bytes.\nAdd 8 bytes.\nAdd a slice of bytes.\nDetermine register class(es) to store the given Cranelift …\nWhat is the register class used for reference types …\nGet a mutable borrow of the underlying register.\nSimilar to <code>MachBuffer::register_constants</code> but registers a …\nRegisters metadata in this <code>MachBuffer</code> about the <code>constants</code> …\nGet the list of external relocations for this code.\nPerform constant-phi removal on the function.\nReplace all redundant loads with the known values in …\nReserve the first N MachLabels for blocks.\nAttempts to resolve a relocation for this function.\nThe offset of the call’s return address, <em>relative to the </em>…\nSet the flag to request a disassembly when compiling with a\nShared settings module.\nThe start of the region of code corresponding to a source …\nThe start of the range. It is an offset in the generated …\nBegin a region of patchable code. There is one requirement …\nSet the <code>SourceLoc</code> for code from this offset until the …\nReturn the code in this mach buffer as a hex string for …\nReturns the compilation result for this function, …\nUsed to continue using a control plane after the emission …\nTake this buffer’s user strack map metadata.\nPass timing.\nGet the physical register (<code>RealReg</code>), if this register is …\nGet the underlying register, which can be read.\nCreates a string representing this label, for convenience.\nGet the virtual (non-physical) register, if this register …\nGet the total required size for the code.\nEven when trace logging is disabled, the trace macro has a …\nGet the list of trap records for this code.\nTraversals over the IR.\nAny unwind info at a given location.\nEmit a reference to the given label with the given …\nGet the user stack map metadata for this code.\nRegister uses of this call.\nA verifier for ensuring that functions are well formed. It …\nRun the verifier on the function.\nVerify <code>func</code>.\nRun the verifier only if the <code>enable_verifier</code> setting is …\nFlag: do we want a disassembly with the CompiledCode?\nInitialize the structure with the expected number of …\nWhat is the worst-case instruction size emitted by this …\nConverting Cranelift IR to text.\nWrite the <code>data</code> provided at <code>offset</code>, for example when …\nWrite <code>func</code> to <code>w</code> as equivalent text. Use <code>isa</code> to emit …\nKey comparator.\nB-tree mapping from <code>K</code> to <code>V</code>.\nA position in a <code>Map</code> used to navigate and modify the …\nMemory pool for a forest of <code>Map</code> instances.\nAn iterator visiting the key-value pairs of a <code>Map</code>.\nB-tree representing an ordered set of <code>K</code>s using <code>C</code> for …\nA position in a <code>Set</code> used to navigate and modify the …\nMemory pool for a forest of <code>Set</code> instances.\nAn iterator visiting the elements of a <code>Set</code>.\nClear all maps in the forest.\nClear all sets in the forest.\nRemove all entries.\nRemove all entries.\nCompare keys <code>a</code> and <code>b</code>.\nDoes the set contain <code>key</code>?.\nCreate a cursor for navigating this map. The cursor is …\nCreate a cursor for navigating this set. The cursor is …\nGet the current element, or <code>None</code> if the cursor is at the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the value stored for <code>key</code>.\nLook up the value stored for <code>key</code>.\nMove this cursor to <code>key</code>.\nMove this cursor to <code>elem</code>.\nMove this cursor to the first element.\nMove this cursor to the first element.\nInsert <code>(key, value))</code> into the map and leave the cursor at …\nTry to insert <code>elem</code> into the set and leave the cursor at …\nInsert <code>key, value</code> into the map and return the old value …\nTry to insert <code>key</code> into the set.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this cursor pointing to an empty map?\nIs this cursor pointing to an empty set?\nIs this an empty map?\nIs this an empty set?\nCreate an iterator traversing this map. The iterator type …\nCreate an iterator traversing this set. The iterator type …\nGet the current key, or <code>None</code> if the cursor is at the end.\nCreate a new empty forest.\nCreate a new empty forest.\nMake an empty map.\nMake an empty set.\nMove cursor to the next key-value pair and return it.\nMove cursor to the next element and return it.\nMove cursor to the previous key-value pair and return it.\nMove cursor to the previous element and return it.\nRemove the current entry (if any) and return the mapped …\nRemove the current element (if any) and return it. This …\nRemove <code>key</code> from the map and return the removed value for …\nRemove <code>key</code> from the set and return true.\nRetains only the elements specified by the predicate.\nRetains only the elements specified by the predicate.\nBinary search for <code>k</code> in an ordered slice.\nGet the current value, or <code>None</code> if the cursor is at the end.\nGet a mutable reference to the current value, or <code>None</code> if …\nAArch64 GOT Page Set the immediate value of an ADRP to …\nAArch64 GOT Low bits Set the LD/ST immediate field to bits …\nAarch64 TLSDESC Add Lo12 This is equivalent to …\nAarch64 TLSDESC Adr Page21 This is equivalent to …\nAarch64 TLSDESC Call This is equivalent to …\nAarch64 TLSDESC Ld64 Lo12 This is equivalent to …\nabsolute 4-byte\nabsolute 8-byte\nAddend to add to the symbol value.\nArm32 call target\nArm64 call target. Encoded as bottom 26 bits of …\nContainer for information about a vector of compiled code …\nOffset in bytes from the beginning of the function.\nElf x86_64 32 bit signed PC relative offset to two GOT …\nMach-O Aarch64 TLS PC-relative distance to the page of the …\nMach-O Aarch64 TLS Offset within page of TLVP slot.\nMach-O x86_64 32 bit signed PC relative offset to a …\nPulley - call a host function indirectly where the …\nRelocation kinds for every ISA\nRISC-V Call PLT: 32-bit PC-relative function call, macros …\nHigh 20 bits of a 32-bit PC-relative GOT offset relocation\nLow 12 bits of a 32-bit PC-relative relocation (I-Type …\nRISC-V TLS GD: High 20 bits of 32-bit PC-relative TLS GD …\ns390x PC-relative 4-byte offset\ns390x PC-relative 4-byte offset to PLT\ns390x TLS GD64 - 64-bit offset of tls_index for GD symbol …\ns390x TLS GDCall - marker to enable optimization of TLS …\nx86 call to PC-relative 4-byte\nx86 call to PLT-relative 4-byte\nx86 GOT PC-relative 4-byte\nx86 PC-relative 4-byte\nThe 32-bit offset of the target from the beginning of its …\nDisplay trait implementation drops the arch, since its …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nNumber of bytes in total.\nA large bit set backed by dynamically-sized storage.\nA small bitset built on top of a single primitive integer …\nGet <code>n + 1</code> where <code>n</code> is the largest value that can be stored …\nThe maximum number of bits that can be stored in this …\nRemove all elements from this bitset.\nRemove all entries from this bitset.\nCompound bit sets.\nIs <code>i</code> contained in this bitset?\nCheck whether this bitset contains <code>i</code>.\nEnsure there is space in this bitset for the values <code>0..n</code>, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a bitset with the half-open range <code>[lo, hi)</code> …\nInsert <code>i</code> into this bitset.\nInsert <code>i</code> into this bitset.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this bitset empty?\nIs this bitset empty?\nIterate over the elements in this bitset.\nIterate over the items in this set.\nGet the number of elements in this bitset.\nGet the number of elements in this set.\nGet the largest value in this set, or <code>None</code> if this set is …\nReturn the largest number contained in the bitset or None …\nReturn the smallest number contained in this bitset or <code>None</code>…\nConstruct a new, empty bit set.\nCreate a new, empty bitset.\nRemoves and returns the largest value in this set.\nRemove and return the largest value in the bitset.\nRemove and return the smallest value in the bitset.\nRemove <code>i</code> from this bitset.\nRemove <code>i</code> from this bitset.\nScalar bitsets.\nConstruct a new, empty bit set with space reserved to …\nA large bit set backed by dynamically-sized storage.\nAn iterator over the elements in a <code>CompoundBitSet</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAn iterator over the elements in a <code>ScalarBitSet</code>.\nA small bitset built on top of a single primitive integer …\nA trait implemented by all integers that can be used as …\nCount the number of bits set in this integer.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCount the number of leading zeros.\nCount the number of trailing zeros.\nA utility for pretty-printing the CFG of a <code>Function</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new CFGPrinter.\nWrite the CFG for this function to <code>w</code>.\nA shim for ControlPlane when chaos mode is disabled. …\nReturns the argument unchanged.\nReturns an arbitrary value. This variant is used when …\nReturns a pseudo-random boolean. This variant is used when …\nCalls <code>U::from(self)</code>.\nSet the fuel limit. This variant is used when chaos mode …\nShuffles the items in the slice into a pseudo-random …\nReturns a new iterator over the same items as the input …\nCursor is pointing after the end of a block. New …\nCursor is pointing at an existing instruction. New …\nCursor is before the beginning of a block. No instructions …\nAll cursor types implement the <code>Cursor</code> which provides …\nThe possible positions of a cursor.\nFunction cursor.\nCursor is not pointing anywhere. No instructions can be …\nRebuild this cursor positioned after <code>inst</code>.\nRebuild this cursor positioned at the bottom of <code>block</code>.\nRebuild this cursor positioned at the first insertion …\nRebuild this cursor positioned at the first instruction in …\nRebuild this cursor positioned at <code>inst</code>.\nRebuild this cursor positioned at the last instruction in …\nRebuild this cursor positioned at <code>pos</code>.\nRebuild this cursor positioned at the top of <code>block</code>.\nGet the block corresponding to the current position.\nGet the instruction corresponding to the current position, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe referenced function.\nGo to the position after a specific instruction, which …\nGo to the bottom of <code>block</code> which must be inserted into the …\nGo to the position for inserting instructions at the …\nGo to the first instruction in <code>block</code>.\nGo to a specific instruction which must be inserted in the …\nGo to the last instruction in <code>block</code>.\nGo to the top of <code>block</code> which must be inserted into the …\nCreate an instruction builder that inserts an instruction …\nInsert a block at the current position and switch to it.\nInsert an instruction at the current position.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBorrow a reference to the function layout that this cursor …\nBorrow a mutable reference to the function layout that …\nCreate a new <code>FuncCursor</code> pointing nowhere.\nGo to the top of the next block in layout order and return …\nMove to the next instruction in the same block and return …\nGet the current cursor position.\nGo to the bottom of the previous block in layout order and …\nMove to the previous instruction in the same block and …\nRemove the instruction under the cursor.\nRemove the instruction under the cursor.\nSet the current position.\nSet the source location that should be assigned to new …\nGet the source location that should be assigned to new …\nUse the source location of <code>inst</code> for future instructions.\nExchange this cursor for one with a set source location.\nRepresent a data value. Where Value is an SSA reference, …\nRecord failures to cast DataValue.\nHelper structure for printing bracket-enclosed vectors of …\nPerforms a bitwise comparison over the contents of …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTry to cast an immediate integer (a wrapped <code>i64</code> on most …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn true if the value is a vector (i.e. <code>DataValue::V128</code>…\nRead a DataValue from a slice using a given Type in …\nRead a DataValue from a slice using a given Type in …\nRead a DataValue from a slice using a given Type with …\nRead a DataValue from a memory location using a given Type …\nConverts <code>self</code> to big endian from target’s endianness.\nConverts <code>self</code> to little endian from target’s endianness.\nReturn the Cranelift IR Type for this DataValue.\nHelper function for displaying <code>Vec&lt;DataValue&gt;</code>.\nWrite a DataValue to a slice in big-endian byte order.\nWrite a DataValue to a slice in little-endian byte order.\nWrite a DataValue to a slice in native-endian byte order.\nWrite a DataValue to a memory location in native-endian …\nHelper for printing lists.\nPrefix added to the log file names, just before the thread …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAn iterator that enumerates the direct children of a block …\nThe dominator tree for a single function.\nOptional pre-order information that can be computed for a …\nGet the CFG post-order of blocks that was used to compute …\nGet an iterator over CFG reverse post-order of blocks used …\nGet an iterator over the direct children of <code>block</code> in the …\nClear the data structures used to represent the dominator …\nReset and compute a CFG post-order and dominator tree.\nRecompute this data structure to match <code>domtree</code>.\nReturns <code>true</code> if <code>a</code> dominates <code>b</code>.\nFast, constant time dominance check with block granularity.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the immediate dominator of <code>block</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs <code>block</code> reachable from the entry block?\nCheck if the dominator tree is in a valid state.\nAllocate a new blank dominator tree. Use <code>compute</code> to …\nCreate a new blank <code>DominatorTreePreorder</code>.\nCompare two program points according to the dominator tree …\nCompare two blocks according to the dominator pre-order.\nCompare two program points relative to a reverse …\nCompare two blocks relative to the reverse post-order.\nAllocate and compute a dominator tree.\nA slice mapping <code>K -&gt; V</code> allocating dense entity references.\nA small list of entity references allocated from a pool.\nA type wrapping a small integer index should implement …\nA set of <code>K</code> for densely indexed entity references.\nIterate over all keys in order.\nIterator type returned by <code>iter_entity_range</code>.\nIterate over all keys in order.\nIterate over all keys in order.\nA memory pool for storing lists of <code>T</code>.\nA primary mapping <code>K -&gt; V</code> allocating dense entity …\nA mapping <code>K -&gt; V</code> for densely indexed entity references.\nHelper trait used to add <code>signed()</code> methods to primitive …\nThe signed integer for this type which has the same width.\nA sparse mapping of entity references.\nTrait for extracting keys from values stored in a <code>SparseMap</code>…\nA sparse set of entity references.\nHelper trait used to add <code>unsigned()</code> methods to primitive …\nThe unsigned integer for this type which has the same …\nGet the list as a mutable slice.\nGet the values as a slice.\nGet the list as a slice.\nPerforms a binary search on the values with a key …\nGet the capacity of this pool. This will be somewhat higher\nReturns the number of elements the map can hold without …\nRemove all elements from the mapping.\nRemoves all elements from the list.\nClear the pool, forgetting about all lists that use it.\nRemove all entries from this map.\nRemove all entries from this map.\nRemove all entries from this set.\nGet the element at <code>k</code> if it exists.\nReturn <code>true</code> if the map contains a value corresponding to …\nCopies a slice from an entity list in the same pool to a …\nCreate a deep clone of the list, which does not alias the …\nEnsure that the set has enough capacity to hold <code>capacity</code> …\nMacro which provides the common implementation of a 32-bit …\nAppends multiple elements to the back of the list.\nGet the first element from the list.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs a list from an iterator.\nCreate a new slice from a raw pointer. A safer way to …\nCreate a new list with the contents initialized from a …\nReturns a reference to the value corresponding to the key.\nGet the element at <code>k</code> if it exists.\nGet a single element from the list.\nGet the element at <code>k</code> if it exists.\nGet the element at <code>k</code> if it exists.\nReturns mutable references to many elements at once.\nReturns a mutable reference to the value corresponding to …\nGet the element at <code>k</code> if it exists, mutable version.\nGet a mutable reference to a single element from the list.\nGet the element at <code>k</code> if it exists, mutable version.\nGrow the list by inserting <code>count</code> elements at <code>index</code>.\nGet the index that was used to create this entity …\nInsert a value into the map.\nInserts an element as position <code>index</code> in the list, shifting …\nInsert the element at <code>k</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes this <code>PrimaryMap</code> and produces a <code>BoxedSlice</code>.\nReturns true is the map contains no elements.\nIs this map completely empty?\nReturns <code>true</code> if the list has a length of 0.\nIs this map completely empty?\nIs this map completely empty?\nIs this set completely empty?\nCheck if <code>k</code> is a valid key in the map.\nReturns <code>true</code> if the list is valid\nCheck if <code>k</code> is a valid key in the map.\nIterate over all the keys and values in this map.\nIterate over all the keys and values in this map.\nIterate over all the keys and values in this map.\nIterate over a <code>Range&lt;E: EntityRef&gt;</code>, yielding a sequence of …\nIterate over all the keys and values in this map, mutable …\nIterate over all the keys and values in this map, mutable …\nIterate over all the keys and values in this map, mutable …\nGet the key of this sparse map value. This key is not …\nIterate over all the keys in this map.\nIterate over all the keys in this map.\nIterate over all the keys in this map.\nIterate over all the keys in this set.\nReturns the last element that was inserted in the map.\nReturns the last element that was inserted in the map.\nReturns the last element that was inserted in the map.\nReturns the number of elements in the map.\nGet the total number of entity references created.\nGet the number of elements in the list.\nGet the total number of entity references created.\nCreate a new entity reference from a small integer. This …\nCreate an <code>Iter</code> iterator that visits the <code>PrimaryMap</code> keys …\nCreate an <code>IterMut</code> iterator that visits the <code>PrimaryMap</code> keys …\nCreate a new empty mapping.\nCreate a new empty list.\nCreate a new list pool.\nCreate a new empty map.\nCreate a new empty map.\nCreate a new empty set.\nGet the key that will be assigned to the next pushed value.\nCompact representation of <code>Option&lt;T&gt;</code> for types with a …\nRemove the last value from the map.\nRemoves and returns the entity from the set if it exists.\nAppends an element to the back of the list. Returns the …\nAppend <code>v</code> to the mapping, assigning a new key which is …\nRemove a value from the map and return it.\nRemoves the element at position <code>index</code> from the list. …\nReserves capacity for at least <code>additional</code> more elements to …\nReserves the minimum capacity for exactly <code>additional</code> more …\nResize the map to have <code>n</code> entries by adding default entries …\nShrinks the capacity of the <code>PrimaryMap</code> as much as possible.\nView this unsigned integer as a signed integer of the same …\nRemoves the element at <code>index</code> in constant time by switching …\nTake all elements from this list and return them as a new …\nShortens the list down to <code>len</code> elements.\nView this signed integer as an unsigned integer of the …\nGet an iterator over the values in the map.\nIterate over all the values in this map.\nIterate over all the values in this map.\nIterate over all the values in this map.\nIterate over all the values in this map, mutable edition.\nIterate over all the values in this map, mutable edition.\nIterate over all the values in this map, mutable edition.\nCreate a new list pool with the given capacity for data …\nCreate a new, empty map with the specified capacity.\nCreate a new empty map with the given capacity.\nCreates a new empty set with the specified capacity.\nCreate a new empty map with a specified default value.\nCreate a <code>Keys</code> iterator that visits <code>len</code> entities starting …\nMemory allocation APIs\nUtilities for dynamic typing or type reflection.\nSIMD and vendor intrinsics module.\nUtilities for the array primitive type.\nOperations on ASCII strings and characters.\nAsserts that a boolean expression is <code>true</code> at runtime.\nAsserts that two expressions are equal to each other …\nUnstable module containing the unstable <code>assert_matches</code> …\nAsserts that two expressions are not equal to each other …\nChecks that the preconditions of an unsafe function are …\nComposable asynchronous iteration.\nUnstable module containing the unstable <code>autodiff</code> macro.\nUtilities for working with borrowed data.\nThe <code>ByteStr</code> type and trait implementations.\nShareable mutable containers.\nEvaluates boolean combinations of configuration flags at …\nA macro for defining <code>#[cfg]</code> match-like statements.\nUtilities for the <code>char</code> primitive type.\nThe <code>Clone</code> trait for types that cannot be ‘implicitly …\nUtilities for comparing and ordering values.\nExpands to the column number at which it was invoked.\nCauses compilation to fail with the given error message …\nConcatenates literals into a static string slice.\nConcatenates literals into a byte slice.\nConcatenates identifiers into one identifier.\nSame as <code>format_args</code>, but can be used in some const …\nTraits for conversions between types.\nAsserts that a boolean expression is <code>true</code> at runtime.\nAsserts that two expressions are equal to each other.\nAsserts that two expressions are not equal to each other.\nThe <code>Default</code> trait for types with a default value.\nInspects an environment variable at compile time.\nInterfaces for working with Errors.\nConstants for the <code>f128</code> quadruple-precision floating point …\nConstants for the <code>f16</code> half-precision floating point type.\nConstants for the <code>f32</code> single-precision floating point type.\nConstants for the <code>f64</code> double-precision floating point type.\nPlatform-specific types, as defined by C.\nExpands to the file name in which it was invoked.\nUtilities for formatting and printing strings.\nConstructs parameters for the other string-formatting …\nSame as <code>format_args</code>, but adds a newline in the end.\nAsynchronous basic functionality.\nGeneric hashing support.\nHints to compiler that affects how code should be emitted …\nRedundant constants module for the <code>i128</code> primitive type.\nRedundant constants module for the <code>i16</code> primitive type.\nRedundant constants module for the <code>i32</code> primitive type.\nRedundant constants module for the <code>i64</code> primitive type.\nRedundant constants module for the <code>i8</code> primitive type.\nParses a file as an expression or an item according to the …\nIncludes a file as a reference to a byte array.\nIncludes a UTF-8 encoded file as a string.\nCompiler intrinsics.\nTraits, helpers, and type definitions for core I/O …\nRedundant constants module for the <code>isize</code> primitive type.\nComposable external iteration.\nExpands to the line number on which it was invoked.\nPrints passed tokens into the standard output.\nPrimitive traits and types representing basic properties …\nReturns whether the given expression matches the provided …\nBasic functions for dealing with memory.\nExpands to a string that represents the current module …\nNetworking primitives for IP communication.\nNumeric traits and functions for the built-in numeric …\nOverloadable operators.\nOptional values.\nOptionally inspects an environment variable at compile …\nPanic support in the standard library.\nPanics the current thread.\nPanic support for core\nHelper module for exporting the <code>pattern_type</code> macro\nCreates a pattern type.\nTypes that pin data to a location in memory.\nThe core prelude\nThis module reexports the primitive types to allow usage …\nManually manage memory through raw pointers.\nRandom value generation.\nExperimental replacement range types\nError handling with the <code>Result</code> type.\nPortable SIMD module.\nSlice management and manipulation.\nString manipulation.\nStringifies its arguments.\nSynchronization primitives\nTypes and Traits for working with asynchronous tasks.\nTemporal quantification.\nIndicates unfinished code.\nEnables or disables tracing functionality used for …\nUnwraps a result or propagates its error.\nRedundant constants module for the <code>u128</code> primitive type.\nRedundant constants module for the <code>u16</code> primitive type.\nRedundant constants module for the <code>u32</code> primitive type.\nRedundant constants module for the <code>u64</code> primitive type.\nRedundant constants module for the <code>u8</code> primitive type.\nProvides the <code>assert_unsafe_precondition</code> macro as well as …\nIndicates unimplemented code by panicking with a message …\nIndicates unreachable code.\nOperators used to turn types into unsafe binders and back.\nRedundant constants module for the <code>usize</code> primitive type.\nWrites formatted data into a buffer.\nWrites formatted data into a buffer, with a newline …\nThe <code>AllocError</code> error indicates an allocation failure that …\nAn implementation of <code>Allocator</code> can allocate, grow, shrink, …\nA memory allocator that can be registered as the standard …\nLayout of a block of memory.\nThe <code>LayoutError</code> is returned when the parameters given to …\nThe minimum byte alignment for a memory block of this …\nCreates a layout describing the record that can hold a …\nAllocates memory as described by the given <code>layout</code>.\nBehaves like <code>alloc</code>, but also ensures that the contents are …\nAttempts to allocate a block of memory.\nBehaves like <code>allocate</code>, but also ensures that the returned …\nCreates a layout describing the record for a <code>[T; n]</code>.\nCreates a “by reference” adapter for this instance of …\nCreates a <code>NonNull</code> that is dangling, but well-aligned for …\nDeallocates the block of memory at the given <code>ptr</code> pointer …\nDeallocates the memory referenced by <code>ptr</code>.\nCreates a layout describing the record for <code>self</code> followed by\nCreates a layout describing the record for <code>self</code> followed by\nProduces layout describing a record that could be used to …\nProduces layout describing a record that could be used to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstructs a <code>Layout</code> from a given <code>size</code> and <code>align</code>, or …\nCreates a layout, bypassing all checks.\nAttempts to extend the memory block.\nBehaves like <code>grow</code>, but also ensures that the new contents …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstructs a <code>Layout</code> suitable for holding a value of type <code>T</code>.\nCreates a layout by rounding the size of this layout up to …\nReturns the amount of padding we must insert after <code>self</code> to …\nShrinks or grows a block of memory to the given <code>new_size</code> …\nCreates a layout describing the record for <code>n</code> instances of …\nCreates a layout describing the record for <code>n</code> instances of …\nAttempts to shrink the memory block.\nThe minimum size in bytes for a memory block of this …\nA trait to emulate dynamic typing.\nA <code>TypeId</code> represents a globally unique identifier for a …\nReturns some mutable reference to the inner value if it is …\nForwards to the method defined on the type <code>dyn Any</code>.\nForwards to the method defined on the type <code>Any</code>.\nReturns a mutable reference to the inner value as type …\nForwards to the method defined on the type <code>dyn Any</code>.\nForwards to the method defined on the type <code>Any</code>.\nForwards to the method defined on the type <code>dyn Any</code>.\nReturns some reference to the inner value if it is of type …\nForwards to the method defined on the type <code>Any</code>.\nReturns a reference to the inner value as type <code>dyn T</code>.\nForwards to the method defined on the type <code>dyn Any</code>.\nForwards to the method defined on the type <code>Any</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nForwards to the method defined on the type <code>dyn Any</code>.\nReturns <code>true</code> if the inner type is the same as <code>T</code>.\nForwards to the method defined on the type <code>Any</code>.\nReturns the <code>TypeId</code> of the type this generic function has …\nGets the <code>TypeId</code> of <code>self</code>.\nReturns the name of a type as a string slice.\nReturns the type name of the pointed-to value as a string …\nInline assembly.\nCompiles to a target-specific software breakpoint …\nModule-level inline assembly.\nInline assembly used in combination with <code>#[naked]</code> …\nPlatform-specific intrinsics for the <code>x86_64</code> platform.\nResult of the <code>cpuid</code> instruction.\nEqual (ordered, non-signaling)\nEqual (ordered, signaling)\nEqual (unordered, non-signaling)\nEqual (unordered, signaling)\nFalse (ordered, non-signaling)\nFalse (ordered, signaling)\nGreater-than-or-equal (ordered, non-signaling)\nGreater-than-or-equal (ordered, signaling)\nGreater-than (ordered, non-signaling)\nGreater-than (ordered, signaling)\nLess-than-or-equal (ordered, non-signaling)\nLess-than-or-equal (ordered, signaling)\nLess-than (ordered, non-signaling)\nLess-than (ordered, signaling)\nNot-equal (ordered, non-signaling)\nNot-equal (ordered, signaling)\nNot-equal (unordered, non-signaling)\nNot-equal (unordered, signaling)\nNot-greater-than-or-equal (unordered, non-signaling)\nNot-greater-than-or-equal (unordered, signaling)\nNot-greater-than (unordered, non-signaling)\nNot-greater-than (unordered, signaling)\nNot-less-than-or-equal (unordered, non-signaling)\nNot-less-than-or-equal (unordered, signaling)\nNot-less-than (unordered, non-signaling)\nNot-less-than (unordered, signaling)\nOrdered (non-signaling)\nOrdered (signaling)\nTrue (unordered, non-signaling)\nTrue (unordered, signaling)\nUnordered (non-signaling)\nUnordered (signaling)\nThe <code>_MM_CMPINT_ENUM</code> type used to specify comparison …\nEqual\nFalse\nLess-than-or-equal\nLess-than\nNot-equal\nNot less-than-or-equal\nNot less-than\nTrue\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_EXCEPTION_STATE</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_FLUSH_ZERO_MODE</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nround up and do not suppress exceptions\nuse MXCSR.RC; see <code>vendor::_MM_SET_ROUNDING_MODE</code>\nround down and do not suppress exceptions\nuse MXCSR.RC and suppress exceptions; see …\nround to nearest and do not suppress exceptions\nsuppress exceptions\ndo not suppress exceptions\nuse MXCSR.RC and do not suppress exceptions; see …\nround to nearest\nround down\nround up\ntruncate\ntruncate and do not suppress exceptions\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nSee <code>_mm_prefetch</code>.\nThe <code>MM_MANTISSA_NORM_ENUM</code> type used to specify mantissa …\nThe <code>MM_MANTISSA_SIGN_ENUM</code> type used to specify mantissa …\ninterval [1, 2)\ninterval [0.5, 1)\ninterval [0.5, 2)\ninterval [0.75, 1.5)\nDEST = NaN if sign(SRC) = 1\nsign = sign(SRC)\nsign = 0\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_EXCEPTION_MASK</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nThe <code>MM_PERM_ENUM</code> type used to specify shuffle operations …\nSee <code>_mm_setcsr</code>\nSee <code>_MM_GET_ROUNDING_MODE</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nSee <code>_mm_setcsr</code>\nA utility function for creating masks to use with Intel …\nTranspose the 4x4 matrix formed by 4 rows of __m128 in …\n<strong>Mask only</strong>: return the bit mask\nFor each character in <code>a</code>, find if it is in <code>b</code> <em>(Default)</em>\nThe strings defined by <code>a</code> and <code>b</code> are equal\nSearch for the defined substring in the target\nFor each character in <code>a</code>, determine if …\n<strong>Index only</strong>: return the least significant bit <em>(Default)</em>\nNegates results only before the end of the string\nDo not negate results before the end of the string\n<strong>Index only</strong>: return the most significant bit\nNegates results\nDo not negate results <em>(Default)</em>\nString contains signed 8-bit characters\nString contains unsigned 16-bit characters\nString contains unsigned 8-bit characters <em>(Default)</em>\n<strong>Mask only</strong>: return the byte mask\nString contains unsigned 16-bit characters\nTransaction abort due to the transaction using too much …\nTransaction abort due to a memory conflict with another …\nTransaction abort due to a debug trap.\nTransaction explicitly aborted with xabort. The parameter …\nTransaction abort in a inner nested transaction.\nTransaction retry is possible.\nTransaction successfully started.\n<code>XFEATURE_ENABLED_MASK</code> for <code>XCR</code>\nSee <code>__cpuid_count</code>.\nReturns the result of the <code>cpuid</code> instruction for a given …\nReturns the highest-supported <code>leaf</code> (<code>EAX</code>) and sub-leaf (<code>ECX</code>…\n128-bit wide set of four <code>f32</code> types, x86-specific\n128-bit wide set of eight <code>u16</code> types, x86-specific\n128-bit wide set of two <code>f64</code> types, x86-specific\n128-bit wide set of 8 <code>f16</code> types, x86-specific\n128-bit wide integer vector type, x86-specific\n256-bit wide set of eight <code>f32</code> types, x86-specific\n256-bit wide set of 16 <code>u16</code> types, x86-specific\n256-bit wide set of four <code>f64</code> types, x86-specific\n256-bit wide set of 16 <code>f16</code> types, x86-specific\n256-bit wide integer vector type, x86-specific\n512-bit wide set of sixteen <code>f32</code> types, x86-specific\n512-bit wide set of 32 <code>u16</code> types, x86-specific\n512-bit wide set of eight <code>f64</code> types, x86-specific\n512-bit wide set of 32 <code>f16</code> types, x86-specific\n512-bit wide integer vector type, x86-specific\nThe <code>__mmask16</code> type used in AVX-512 intrinsics, a 16-bit …\nThe <code>__mmask32</code> type used in AVX-512 intrinsics, a 32-bit …\nThe <code>__mmask64</code> type used in AVX-512 intrinsics, a 64-bit …\nThe <code>__mmask8</code> type used in AVX-512 intrinsics, a 8-bit …\nReads the current value of the processor’s time-stamp …\nAdds unsigned 32-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit …\nAdds unsigned 64-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit …\nAdds unsigned 32-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit …\nAdds unsigned 64-bit integers <code>a</code> and <code>b</code> with unsigned 8-bit …\nBitwise logical <code>AND</code> of inverted <code>a</code> with <code>b</code>.\nBitwise logical <code>AND</code> of inverted <code>a</code> with <code>b</code>.\nExtracts bits of <code>a</code> specified by <code>control</code> into the least …\nExtracts bits of <code>a</code> specified by <code>control</code> into the least …\nExtracts bits in range [<code>start</code>, <code>start</code> + <code>length</code>) from <code>a</code> into …\nExtracts bits in range [<code>start</code>, <code>start</code> + <code>length</code>) from <code>a</code> into …\nExtracts bits of <code>a</code> specified by <code>control</code> into the least …\nExtracts bits of <code>a</code> specified by <code>control</code> into the least …\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>.\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>.\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>…\nClears all bits below the least significant zero bit of <code>x</code>.\nClears all bits below the least significant zero bit of <code>x</code>.\nSets all bits of <code>x</code> to 1 except for the least significant …\nSets all bits of <code>x</code> to 1 except for the least significant …\nSets the least significant zero bit of <code>x</code> and clears all …\nSets the least significant zero bit of <code>x</code> and clears all …\nSets the least significant zero bit of <code>x</code> and clears all …\nSets the least significant zero bit of <code>x</code> and clears all …\nSets the least significant zero bit of <code>x</code>.\nSets the least significant zero bit of <code>x</code>.\nSets all bits of <code>x</code> below the least significant one.\nSets all bits of <code>x</code> below the least significant one.\nExtracts lowest set isolated bit.\nExtracts lowest set isolated bit.\nClears least significant bit and sets all other bits.\nClears least significant bit and sets all other bits.\nGets mask up to lowest set bit.\nGets mask up to lowest set bit.\nResets the lowest set bit of <code>x</code>.\nResets the lowest set bit of <code>x</code>.\nReturns an integer with the reversed byte order of x\nReturns an integer with the reversed byte order of x\nZeroes higher bits of <code>a</code> &gt;= <code>index</code>.\nZeroes higher bits of <code>a</code> &gt;= <code>index</code>.\nConvert 16-bit mask a into an integer value, and store the …\nConvert 32-bit mask a into an integer value, and store the …\nConvert 64-bit mask a into an integer value, and store the …\nConvert 8-bit mask a to a 32-bit integer value and store …\nConvert 32-bit integer value a to an 16-bit mask and store …\nConvert integer value a into an 32-bit mask, and store the …\nConvert 32-bit integer value a to an 8-bit mask and store …\nConvert integer value a into an 64-bit mask, and store the …\nRestores the <code>XMM</code>, <code>MMX</code>, <code>MXCSR</code>, and <code>x87</code> FPU registers from …\nRestores the <code>XMM</code>, <code>MMX</code>, <code>MXCSR</code>, and <code>x87</code> FPU registers from …\nSaves the <code>x87</code> FPU, <code>MMX</code> technology, <code>XMM</code>, and <code>MXCSR</code> …\nSaves the <code>x87</code> FPU, <code>MMX</code> technology, <code>XMM</code>, and <code>MXCSR</code> …\nAdd 16-bit masks a and b, and store the result in dst.\nAdd 32-bit masks in a and b, and store the result in k.\nAdd 64-bit masks in a and b, and store the result in k.\nAdd 8-bit masks a and b, and store the result in dst.\nCompute the bitwise AND of 16-bit masks a and b, and store …\nCompute the bitwise AND of 32-bit masks a and b, and store …\nCompute the bitwise AND of 64-bit masks a and b, and store …\nBitwise AND of 8-bit masks a and b, and store the result …\nCompute the bitwise NOT of 16-bit masks a and then AND …\nCompute the bitwise NOT of 32-bit masks a and then AND …\nCompute the bitwise NOT of 64-bit masks a and then AND …\nBitwise AND NOT of 8-bit masks a and b, and store the …\nCompute the bitwise NOT of 16-bit mask a, and store the …\nCompute the bitwise NOT of 32-bit mask a, and store the …\nCompute the bitwise NOT of 64-bit mask a, and store the …\nBitwise NOT of 8-bit mask a, and store the result in dst.\nCompute the bitwise OR of 16-bit masks a and b, and store …\nCompute the bitwise OR of 32-bit masks a and b, and store …\nCompute the bitwise OR of 64-bit masks a and b, and store …\nBitwise OR of 8-bit masks a and b, and store the result in …\nCompute the bitwise OR of 16-bit masks a and b. If the …\nCompute the bitwise OR of 32-bit masks a and b. If the …\nCompute the bitwise OR of 64-bit masks a and b. If the …\nCompute the bitwise OR of 8-bit masks a and b. If the …\nCompute the bitwise OR of 16-bit masks a and b. If the …\nCompute the bitwise OR of 32-bit masks a and b. If the …\nCompute the bitwise OR of 64-bit masks a and b. If the …\nCompute the bitwise OR of 8-bit masks a and b. If the …\nCompute the bitwise OR of 16-bit masks a and b. If the …\nCompute the bitwise OR of 32-bit masks a and b. If the …\nCompute the bitwise OR of 64-bit masks a and b. If the …\nCompute the bitwise OR of 8-bit masks a and b. If the …\nShift 16-bit mask a left by count bits while shifting in …\nShift the bits of 32-bit mask a left by count while …\nShift the bits of 64-bit mask a left by count while …\nShift 8-bit mask a left by count bits while shifting in …\nShift 16-bit mask a right by count bits while shifting in …\nShift the bits of 32-bit mask a right by count while …\nShift the bits of 64-bit mask a right by count while …\nShift 8-bit mask a right by count bits while shifting in …\nCompute the bitwise AND of 16-bit masks a and b, and if …\nCompute the bitwise AND of 32-bit masks a and b, and if …\nCompute the bitwise AND of 64-bit masks a and b, and if …\nCompute the bitwise AND of 8-bit masks a and b, and if the …\nCompute the bitwise NOT of 16-bit mask a and then AND with …\nCompute the bitwise NOT of 32-bit mask a and then AND with …\nCompute the bitwise NOT of 64-bit mask a and then AND with …\nCompute the bitwise NOT of 8-bit mask a and then AND with …\nCompute the bitwise AND of 16-bit masks a and  b, if the …\nCompute the bitwise AND of 32-bit masks a and  b, if the …\nCompute the bitwise AND of 64-bit masks a and  b, if the …\nCompute the bitwise AND of 8-bit masks a and  b, if the …\nCompute the bitwise XNOR of 16-bit masks a and b, and …\nCompute the bitwise XNOR of 32-bit masks a and b, and …\nCompute the bitwise XNOR of 64-bit masks a and b, and …\nBitwise XNOR of 8-bit masks a and b, and store the result …\nCompute the bitwise XOR of 16-bit masks a and b, and store …\nCompute the bitwise XOR of 32-bit masks a and b, and store …\nCompute the bitwise XOR of 64-bit masks a and b, and store …\nBitwise XOR of 8-bit masks a and b, and store the result …\nLoad 16-bit mask from memory\nLoad 32-bit mask from memory into k.\nLoad 64-bit mask from memory into k.\nLoad 8-bit mask from memory\nCounts the leading most significant zero bits.\nCounts the leading most significant zero bits.\nComputes the absolute values of packed 16-bit integers in <code>a</code>…\nComputes the absolute values of packed 32-bit integers in <code>a</code>…\nCompute the absolute value of packed signed 64-bit …\nComputes the absolute values of packed 8-bit integers in <code>a</code>.\nFinds the absolute value of each packed half-precision …\nAdds packed 16-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 32-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 64-bit integers in <code>a</code> and <code>b</code>.\nAdds packed 8-bit integers in <code>a</code> and <code>b</code>.\nAdds packed double-precision (64-bit) floating-point …\nAdd packed half-precision (16-bit) floating-point elements …\nAdds packed single-precision (32-bit) floating-point …\nAdds packed 16-bit integers in <code>a</code> and <code>b</code> using saturation.\nAdds packed 8-bit integers in <code>a</code> and <code>b</code> using saturation.\nAdds packed unsigned 16-bit integers in <code>a</code> and <code>b</code> using …\nAdds packed unsigned 8-bit integers in <code>a</code> and <code>b</code> using …\nAlternatively adds and subtracts packed double-precision …\nAlternatively adds and subtracts packed single-precision …\nPerforms one round of an AES decryption flow on each …\nPerforms the last round of an AES decryption flow on each …\nPerforms one round of an AES encryption flow on each …\nPerforms the last round of an AES encryption flow on each …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenates pairs of 16-byte blocks in <code>a</code> and <code>b</code> into a …\nComputes the bitwise AND of a packed double-precision …\nComputes the bitwise AND of packed single-precision …\nComputes the bitwise AND of 256 bits (representing integer …\nComputes the bitwise NOT of packed double-precision …\nComputes the bitwise NOT of packed single-precision …\nComputes the bitwise NOT of 256 bits (representing integer …\nAverages packed unsigned 16-bit integers in <code>a</code> and <code>b</code>.\nAverages packed unsigned 8-bit integers in <code>a</code> and <code>b</code>.\nConvert scalar BF16 (16-bit) floating point element stored …\nConvert scalar half-precision (16-bit) floating-point …\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBlends packed 16-bit integers from <code>a</code> and <code>b</code> using control …\nBlends packed 32-bit integers from <code>a</code> and <code>b</code> using control …\nBlends packed double-precision (64-bit) floating-point …\nBlends packed single-precision (32-bit) floating-point …\nBlends packed 8-bit integers from <code>a</code> and <code>b</code> using <code>mask</code>.\nBlends packed double-precision (64-bit) floating-point …\nBlends packed single-precision (32-bit) floating-point …\nBroadcasts the lower 2 packed single-precision (32-bit) …\nBroadcast the 4 packed single-precision (32-bit) …\nBroadcasts the 2 packed double-precision (64-bit) …\nBroadcasts the lower 2 packed 32-bit integers from a to …\nBroadcast the 4 packed 32-bit integers from a to all …\nBroadcasts the 2 packed 64-bit integers from a to all …\nBroadcasts 128 bits from memory (composed of 2 packed …\nBroadcasts 128 bits from memory (composed of 4 packed …\nBroadcasts a double-precision (64-bit) floating-point …\nBroadcasts a single-precision (32-bit) floating-point …\nBroadcasts the low packed 8-bit integer from <code>a</code> to all …\nBroadcasts the low packed 32-bit integer from <code>a</code> to all …\nBroadcast the low 8-bits from input mask k to all 64-bit …\nBroadcast the low 16-bits from input mask k to all 32-bit …\nBroadcasts the low packed 64-bit integer from <code>a</code> to all …\nBroadcasts the low double-precision (64-bit) …\nBroadcasts 128 bits of integer data from a to all 128-bit …\nBroadcasts the low single-precision (32-bit) …\nBroadcasts the low packed 16-bit integer from a to all …\nShifts 128-bit lanes in <code>a</code> left by <code>imm8</code> bytes while …\nShifts 128-bit lanes in <code>a</code> right by <code>imm8</code> bytes while …\nCasts vector of type __m128d to type __m256d; the upper …\nCasts vector of type __m256d to type __m128d.\nCast vector of type <code>__m256d</code> to type <code>__m256h</code>. This …\nCast vector of type __m256d to type __m256.\nCasts vector of type __m256d to type __m256i.\nCast vector of type <code>__m128h</code> to type <code>__m256h</code>. The upper 8 …\nCast vector of type <code>__m256h</code> to type <code>__m128h</code>. This …\nCast vector of type <code>__m256h</code> to type <code>__m256d</code>. This …\nCast vector of type <code>__m256h</code> to type <code>__m256</code>. This intrinsic …\nCast vector of type <code>__m256h</code> to type <code>__m256i</code>. This …\nCasts vector of type __m128 to type __m256; the upper 128 …\nCasts vector of type __m256 to type __m128.\nCast vector of type __m256 to type __m256d.\nCast vector of type <code>__m256</code> to type <code>__m256h</code>. This intrinsic …\nCasts vector of type __m256 to type __m256i.\nCasts vector of type __m128i to type __m256i; the upper …\nCasts vector of type __m256i to type __m256d.\nCast vector of type <code>__m256i</code> to type <code>__m256h</code>. This …\nCasts vector of type __m256i to type __m256.\nCasts vector of type __m256i to type __m128i.\nRounds packed double-precision (64-bit) floating point …\nRounds packed single-precision (32-bit) floating point …\nPerforms a carry-less multiplication of two 64-bit …\nCompare packed signed 16-bit integers in a and b based on …\nCompare packed signed 32-bit integers in a and b based on …\nCompare packed signed 64-bit integers in a and b based on …\nCompare packed signed 8-bit integers in a and b based on …\nCompare packed unsigned 16-bit integers in a and b based …\nCompare packed unsigned 32-bit integers in a and b based …\nCompare packed unsigned 64-bit integers in a and b based …\nCompare packed unsigned 8-bit integers in a and b based on …\nCompares packed double-precision (64-bit) floating-point …\nCompare packed double-precision (64-bit) floating-point …\nCompare packed half-precision (16-bit) floating-point …\nCompares packed single-precision (32-bit) floating-point …\nCompare packed single-precision (32-bit) floating-point …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed signed 16-bit integers in a and b for …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed 32-bit integers in a and b for equality, …\nCompares packed 64-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed 64-bit integers in a and b for equality, …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> for equality.\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompares packed 16-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 16-bit integers in a and b for …\nCompares packed 32-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 32-bit integers in a and b for …\nCompares packed 64-bit integers in <code>a</code> and <code>b</code> for …\nCompare packed signed 64-bit integers in a and b for …\nCompares packed 8-bit integers in <code>a</code> and <code>b</code> for greater-than.\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed signed 32-bit integers in a and b for …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nCompare packed signed 16-bit integers in a and b for …\nCompare packed 32-bit integers in a and b for not-equal, …\nCompare packed signed 64-bit integers in a and b for …\nCompare packed signed 8-bit integers in a and b for …\nCompare packed unsigned 16-bit integers in a and b for …\nCompare packed unsigned 32-bit integers in a and b for …\nCompare packed unsigned 64-bit integers in a and b for …\nCompare packed unsigned 8-bit integers in a and b for …\nMultiply packed complex numbers in a by the complex …\nTest each 32-bit element of a for equality with all other …\nTest each 64-bit element of a for equality with all other …\nCompute the complex conjugates of complex numbers in a, …\nSign-extend 16-bit integers to 32-bit integers.\nSign-extend 16-bit integers to 64-bit integers.\nConvert packed 16-bit integers in a to packed 8-bit …\nConvert packed signed 16-bit integers in a to packed …\nConvert packed 32-bit integers in a to packed 16-bit …\nSign-extend 32-bit integers to 64-bit integers.\nConvert packed 32-bit integers in a to packed 8-bit …\nConverts packed 32-bit integers in <code>a</code> to packed …\nConvert packed signed 32-bit integers in a to packed …\nConverts packed 32-bit integers in <code>a</code> to packed …\nConvert packed 64-bit integers in a to packed 16-bit …\nConvert packed 64-bit integers in a to packed 32-bit …\nConvert packed 64-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nSign-extend 8-bit integers to 16-bit integers.\nSign-extend 8-bit integers to 32-bit integers.\nSign-extend 8-bit integers to 64-bit integers.\nZeroes extend packed unsigned 16-bit integers in <code>a</code> to …\nZero-extend the lower four unsigned 16-bit integers in <code>a</code> …\nConvert packed unsigned 16-bit integers in a to packed …\nZero-extend unsigned 32-bit integers in <code>a</code> to 64-bit …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nZero-extend unsigned 8-bit integers in <code>a</code> to 16-bit …\nZero-extend the lower eight unsigned 8-bit integers in <code>a</code> …\nZero-extend the lower four unsigned 8-bit integers in <code>a</code> to …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed BF16 (16-bit) floating-point even-indexed …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed BF16 (16-bit) floating-point odd-indexed …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConverts packed BF16 (16-bit) floating-point elements in a …\nConverts packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConverts packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConverts the 8 x 16-bit half-precision float values in the …\nConverts packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConverts packed single-precision (32-bit) floating-point …\nConverts the 8 x 32-bit float values in the 256-bit vector …\nReturns the first element of the input vector of …\nConvert packed signed 16-bit integers in a to packed 8-bit …\nConvert packed signed 32-bit integers in a to packed …\nConvert packed signed 32-bit integers in a to packed 8-bit …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed …\nConvert packed signed 64-bit integers in a to packed 8-bit …\nCopy the lower half-precision (16-bit) floating-point …\nReturns the first element of the input vector of <code>[8 x i32]</code>.\nReturns the first element of the input vector of …\nConverts packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed double-precision (64-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed half-precision (16-bit) floating-point …\nConverts packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nConvert packed unsigned 16-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 32-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed unsigned 64-bit integers in a to packed …\nConvert packed half-precision (16-bit) floating-point …\nConvert packed single-precision (32-bit) floating-point …\nCompute the sum of absolute differences (SADs) of …\nComputes the division of each of the 4 packed 64-bit …\nDivide packed half-precision (16-bit) floating-point …\nComputes the division of each of the 8 packed 32-bit …\nConditionally multiplies the packed single-precision …\nCompute dot-product of BF16 (16-bit) floating-point pairs …\nMultiply groups of 4 adjacent pairs of signed 8-bit …\nMultiply groups of 4 adjacent pairs of signed 8-bit …\nMultiply groups of 4 adjacent pairs of signed 8-bit …\nMultiply groups of 4 adjacent pairs of signed 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 4 adjacent pairs of unsigned 8-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of signed 16-bit …\nMultiply groups of 2 adjacent pairs of unsigned 16-bit …\nMultiply groups of 2 adjacent pairs of unsigned 16-bit …\nMultiply groups of 2 adjacent pairs of unsigned 16-bit …\nMultiply groups of 2 adjacent pairs of unsigned 16-bit …\nExtracts a 16-bit integer from <code>a</code>, selected with <code>INDEX</code>. …\nExtracts a 32-bit integer from <code>a</code>, selected with <code>INDEX</code>.\nExtracts a 64-bit integer from <code>a</code>, selected with <code>INDEX</code>.\nExtracts an 8-bit integer from <code>a</code>, selected with <code>INDEX</code>. …\nExtracts 128 bits (composed of 2 packed double-precision …\nExtracts 128 bits (composed of 4 packed single-precision …\nExtracts 128 bits (composed of integer data) from <code>a</code>, …\nExtract 128 bits (composed of 4 packed single-precision …\nExtracts 128 bits (composed of 2 packed double-precision …\nExtracts 128 bits (of integer data) from <code>a</code> selected with …\nExtract 128 bits (composed of 4 packed 32-bit integers) …\nExtracts 128 bits (composed of 2 packed 64-bit integers) …\nMultiply packed complex numbers in a by the complex …\nMultiply packed complex numbers in a by the complex …\nFix up packed double-precision (64-bit) floating-point …\nFix up packed single-precision (32-bit) floating-point …\nRounds packed double-precision (64-bit) floating point …\nRounds packed single-precision (32-bit) floating point …\nMultiply packed complex numbers in a and b, accumulate to …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiply packed half-precision (16-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiply packed half-precision (16-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiply packed half-precision (16-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiply packed half-precision (16-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiply packed complex numbers in a and b, and store the …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiply packed half-precision (16-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nMultiplies packed double-precision (64-bit) floating-point …\nMultiply packed half-precision (16-bit) floating-point …\nMultiplies packed single-precision (32-bit) floating-point …\nTest packed double-precision (64-bit) floating-point …\nTest packed half-precision (16-bit) floating-point …\nTest packed single-precision (32-bit) floating-point …\nConvert the exponent of each packed double-precision …\nConvert the exponent of each packed half-precision …\nConvert the exponent of each packed single-precision …\nNormalize the mantissas of packed double-precision …\nNormalize the mantissas of packed half-precision (16-bit) …\nNormalize the mantissas of packed single-precision …\nPerforms an affine transformation on the packed bytes in x.\nPerforms an affine transformation on the inverted packed …\nPerforms a multiplication in GF(2^8) on the packed bytes. …\nHorizontally adds adjacent pairs of 16-bit integers in <code>a</code> …\nHorizontally adds adjacent pairs of 32-bit integers in <code>a</code> …\nHorizontal addition of adjacent pairs in the two packed …\nHorizontal addition of adjacent pairs in the two packed …\nHorizontally adds adjacent pairs of 16-bit integers in <code>a</code> …\nHorizontally subtract adjacent pairs of 16-bit integers in …\nHorizontally subtract adjacent pairs of 32-bit integers in …\nHorizontal subtraction of adjacent pairs in the two packed …\nHorizontal subtraction of adjacent pairs in the two packed …\nHorizontally subtract adjacent pairs of 16-bit integers in …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nStores 8 32-bit integer elements from a to memory starting …\nScatter 64-bit integers from a into memory using 32-bit …\nStores 4 double-precision (64-bit) floating-point elements …\nStores 8 single-precision (32-bit) floating-point elements …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nReturns values from <code>slice</code> at offsets determined by …\nStores 4 32-bit integer elements from a to memory starting …\nStores 4 64-bit integer elements from a to memory starting …\nStores 4 double-precision (64-bit) floating-point elements …\nStores 4 single-precision (32-bit) floating-point elements …\nCopies <code>a</code> to result, and inserts the 16-bit integer <code>i</code> into …\nCopies <code>a</code> to result, and inserts the 32-bit integer <code>i</code> into …\nCopies <code>a</code> to result, and insert the 64-bit integer <code>i</code> into …\nCopies <code>a</code> to result, and inserts the 8-bit integer <code>i</code> into …\nCopies <code>a</code> to result, then inserts 128 bits (composed of 2 …\nCopies <code>a</code> to result, then inserts 128 bits (composed of 4 …\nCopies <code>a</code> to result, then inserts 128 bits from <code>b</code> into …\nCopy a to dst, then insert 128 bits (composed of 4 packed …\nCopy a to dst, then insert 128 bits (composed of 2 packed …\nCopies <code>a</code> to <code>dst</code>, then insert 128 bits (of integer data) …\nCopy a to dst, then insert 128 bits (composed of 4 packed …\nCopy a to dst, then insert 128 bits (composed of 2 packed …\nLoads 256-bits of integer data from unaligned memory into …\nLoad 256-bits (composed of 8 packed 32-bit integers) from …\nLoad 256-bits (composed of 4 packed 64-bit integers) from …\nLoads 256-bits (composed of 4 packed double-precision …\nLoad 256-bits (composed of 16 packed half-precision …\nLoads 256-bits (composed of 8 packed single-precision …\nLoads 256-bits of integer data from memory into result. …\nLoads two 128-bit values (composed of 4 packed …\nLoads two 128-bit values (composed of 2 packed …\nLoads two 128-bit values (composed of integer data) from …\nLoad 256-bits (composed of 16 packed 16-bit integers) from …\nLoad 256-bits (composed of 8 packed 32-bit integers) from …\nLoad 256-bits (composed of 4 packed 64-bit integers) from …\nLoad 256-bits (composed of 32 packed 8-bit integers) from …\nLoads 256-bits (composed of 4 packed double-precision …\nLoad 256-bits (composed of 16 packed half-precision …\nLoads 256-bits (composed of 8 packed single-precision …\nLoads 256-bits of integer data from memory into result. …\nCounts the number of leading zero bits in each packed …\nCounts the number of leading zero bits in each packed …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiply packed unsigned 52-bit integers in each 64-bit …\nMultiplies packed signed 16-bit integers in <code>a</code> and <code>b</code>, …\nVertically multiplies each unsigned 8-bit integer from <code>a</code> …\nShuffle 16-bit integers in a and b across lanes using the …\nShuffle 32-bit integers in a and b across lanes using the …\nShuffle 64-bit integers in a and b across lanes using the …\nShuffle 8-bit integers in a and b across lanes using the …\nShuffle double-precision (64-bit) floating-point elements …\nShuffle single-precision (32-bit) floating-point elements …\nMultiply packed complex numbers in a by the complex …\nMultiply packed complex numbers in a and b, accumulate to …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed half-precision (16-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed half-precision (16-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed half-precision (16-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed half-precision (16-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed half-precision (16-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nMultiply packed double-precision (64-bit) floating-point …\nMultiply packed half-precision (16-bit) floating-point …\nMultiply packed single-precision (32-bit) floating-point …\nCompute the absolute value of packed signed 16-bit …\nCompute the absolute value of packed signed 32-bit …\nCompute the absolute value of packed signed 64-bit …\nCompute the absolute value of packed signed 8-bit integers …\nAdd packed 16-bit integers in a and b, and store the …\nAdd packed 32-bit integers in a and b, and store the …\nAdd packed 64-bit integers in a and b, and store the …\nAdd packed 8-bit integers in a and b, and store the …\nAdd packed double-precision (64-bit) floating-point …\nAdd packed half-precision (16-bit) floating-point elements …\nAdd packed single-precision (32-bit) floating-point …\nAdd packed signed 16-bit integers in a and b using …\nAdd packed signed 8-bit integers in a and b using …\nAdd packed unsigned 16-bit integers in a and b using …\nAdd packed unsigned 8-bit integers in a and b using …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenate a and b into a 64-byte immediate result, shift …\nConcatenate pairs of 16-byte blocks in a and b into a …\nPerforms element-by-element bitwise AND between packed …\nCompute the bitwise AND of packed 64-bit integers in a and …\nCompute the bitwise AND of packed double-precision …\nCompute the bitwise AND of packed single-precision …\nCompute the bitwise NOT of packed 32-bit integers in a and …\nCompute the bitwise NOT of packed 64-bit integers in a and …\nCompute the bitwise NOT of packed double-precision …\nCompute the bitwise NOT of packed single-precision …\nAverage packed unsigned 16-bit integers in a and b, and …\nAverage packed unsigned 8-bit integers in a and b, and …\nConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as …\nBlend packed 16-bit integers from a and b using control …\nBlend packed 32-bit integers from a and b using control …\nBlend packed 64-bit integers from a and b using control …\nBlend packed 8-bit integers from a and b using control …\nBlend packed double-precision (64-bit) floating-point …")