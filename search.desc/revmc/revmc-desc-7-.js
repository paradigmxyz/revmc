searchState.loadedDescShard("revmc", 7, "The <code>.debug_line</code> section.\nThe <code>.debug_line_str</code> section.\nThe <code>.debug_loc</code> section.\nThe <code>.debug_loclists</code> section.\nThe <code>.debug_ranges</code> section.\nThe <code>.debug_rnglists</code> section.\nThe <code>.debug_str</code> section.\nReturn the id for the working directory of the compilation …\nDelete an attribute.\nDelete a child entry and all of its children.\nAn additional discriminator used to distinguish between …\nThe <code>.eh_frame</code> section.\nThe pointer encoding for relocations in unwind information.\nReturn the encoding parameters for this line program.\nReturn the encoding parameters for this unit.\nEnd the sequence, and reset the row to its default values.\nReturn the endianity of bytes that are written.\nGet the <code>.debug_info</code> section offset for the given entry.\nSet to true if the instruction is a recommended breakpoint …\nThe encoding to use for addresses in FDEs.\nThe number of FDEs.\nThe source file corresponding to the instruction.\nTrue if the file entries have valid MD5 checksums.\nTrue if the file entries may have valid sizes.\nTrue if the file entries have embedded source code.\nTrue if the file entries may have valid timestamps.\nFor each section, call <code>f</code> once with a shared reference.\nFor each section, call <code>f</code> once with a mutable reference.\nReturn the form that will be used to encode this value.\nReturn the DWARF format for this line program.\nReturn the DWARF format for this unit.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a frame table by reading the data in the given …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a <code>write::Dwarf</code> by converting a <code>read::Dwarf</code>.\nReturns the argument unchanged.\nCreate a line number program by reading the data from the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate an expression from the input expression.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a unit table by reading the data in the given …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerates the line number information instructions for the …\nGet the section with the given <code>id</code>.\nGet the offset\nGet a reference to a location list.\nGet the offset\nGet a reference to a location list.\nGet a reference to a string in the table.\nGet the offset\nGet a reference to a string in the table.\nGet the offset\nGet a reference to a unit.\nGet a reference to an entry.\nGet an attribute.\nGet the value of this attribute.\nGet a reference to a directory entry.\nGet a reference to a file entry.\nGet a reference to the info for a file entry.\nGet a mutable reference to the info for a file entry.\nGet the section with the given <code>id</code>.\nGet a mutable reference to a unit.\nGet a mutable reference to an entry.\nGet an attribute for modification.\nReturns the DWARF section kind for this type.\nReturn the id of a unit.\nReturn the id of this entry.\nReturn true if a sequence has begun.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert into a <code>Vec&lt;u8&gt;</code>.\nReturns true if the line number program has no …\nReturn true if this line program was created with …\nSet to true if the instruction is a recommended breakpoint …\nThe instruction set architecture of the instruction.\nGet an iterator for the units.\nGet a mutable iterator for the units.\nReturn the current section length.\nThe line number within the source file.\nThe line number program for this unit.\nExtra line number programs that are not associated with a …\nA table of strings that will be stored in the …\nA table of strings that will be stored in the …\nA table of location lists used by this unit.\nThe address of the LSDA.\nThe encoding to use for the LSDA address in FDEs.\nA 16-byte MD5 digest of the file contents.\nReturns the ELF section name for this type.\nGet the name of this attribute.\nConstruct an empty <code>EndianVec</code> with the given endianity.\nCreate a new <code>Sections</code> using clones of the given <code>section</code>.\nCreate a new common information entry.\nCreate a new frame description entry for a function.\nCreate a new <code>Dwarf</code> instance.\nCreate a new <code>DwarfUnit</code>.\nCreate a new <code>LineProgram</code>.\nCreate a <code>LineString</code> using the normal form for the given …\nCreate an empty expression.\nCreate a new <code>Unit</code>.\nReturn the index that will be assigned to the next …\nCreate a new <code>LineProgram</code> with no fields set.\nReturn an empty list of offsets.\nReturn an empty list of offsets.\nReturn an empty list of offsets.\nReturn an empty list of offsets.\nReturn the offset of the next write.\nReturn the offset of the next write.\nReturn the offset of the next write.\nReturn the offset of the next write.\nReturn the offset of the next write.\nReturn the offset of the next write.\nReturn the offset of the next write.\nReturn the offset of the next write.\nReturn the offset of the next write.\nReturn the offset of the next write.\nReturn the offset of the next write.\nThe offset within the section where the relocation should …\nAdd an operation to the expression.\nAdd a <code>DW_OP_addr</code> operation to the expression.\nAdd a <code>DW_OP_bit_piece</code> operation to the expression.\nAdd a <code>DW_OP_bra</code> operation to the expression.\nAdd a <code>DW_OP_bregx</code> operation to the expression.\nAdd a <code>DW_OP_call4</code> operation to the expression.\nAdd a <code>DW_OP_call_ref</code> operation to the expression.\nAdd a <code>DW_OP_const_type</code> or <code>DW_OP_GNU_const_type</code> operation …\nAdd a <code>DW_OP_consts</code> operation to the expression.\nAdd a <code>DW_OP_constu</code> operation to the expression.\nAdd a <code>DW_OP_convert</code> or <code>DW_OP_GNU_convert</code> operation to the …\nAdd a <code>DW_OP_deref</code> operation to the expression.\nAdd a <code>DW_OP_deref_size</code> operation to the expression.\nAdd a <code>DW_OP_deref_type</code> or <code>DW_OP_GNU_deref_type</code> operation …\nAdd a <code>DW_OP_entry_value</code> or <code>DW_OP_GNU_entry_value</code> operation …\nAdd a <code>DW_OP_fbreg</code> operation to the expression.\nAdd a <code>DW_OP_GNU_parameter_ref</code> operation to the expression.\nAdd a <code>DW_OP_implicit_pointer</code> or <code>DW_OP_GNU_implicit_pointer</code> …\nAdd a <code>DW_OP_implicit_value</code> operation to the expression.\nThe index of an operation within a VLIW instruction.\nAdd a <code>DW_OP_pick</code> operation to the expression.\nAdd a <code>DW_OP_piece</code> operation to the expression.\nAdd a <code>DW_OP_plus_uconst</code> operation to the expression.\nAdd a <code>DW_OP_regx</code> operation to the expression.\nAdd a <code>DW_OP_regval_type</code> or <code>DW_OP_GNU_regval_type</code> operation …\nAdd a <code>DW_OP_reinterpret</code> or <code>DW_OP_GNU_reinterpret</code> operation …\nAdd a <code>DW_OP_skip</code> operation to the expression.\nAdd a <code>DW_OP_WASM_location 0x1</code> operation to the expression.\nAdd a <code>DW_OP_WASM_location 0x0</code> operation to the expression.\nAdd a <code>DW_OP_WASM_location 0x2</code> operation to the expression.\nAdd a <code>DW_OP_xderef</code> operation to the expression.\nAdd a <code>DW_OP_xderef_size</code> operation to the expression.\nAdd a <code>DW_OP_xderef_type</code> operation to the expression.\nReturn the parent of this entry.\nThe address of the personality function and its encoding.\nSet to true if the instruction is a recommended breakpoint …\nA table of range lists used by this unit.\nCreate an expression from raw bytecode.\nRecord a relocation.\nReturn the id of the root entry.\nReturns a reference to the data for the current row.\nSet an attribute.\nSet the value of this attribute.\nSet whether a <code>DW_AT_sibling</code> attribute will be emitted.\nSet the target of a <code>DW_OP_skip</code> or <code>DW_OP_bra</code> operation .\nReturn <code>true</code> if a <code>DW_AT_sibling</code> attribute will be emitted.\nTrue for signal trampolines.\nThe size of the value to be relocated.\nThe size of the file in bytes, or 0 if not available.\nReturn a reference to the raw slice.\nOptionally some embedded sourcecode.\nA table of strings that will be stored in the <code>.debug_str</code> …\nA table of strings that will be stored in the <code>.debug_str</code> …\nReturn the tag of this entry.\nTake any written data out of the <code>EndianVec</code>, leaving an …\nThe target of the relocation.\nThe implementation defined timestamp of the last …\nGet the <code>.debug_info</code> section offset for the given unit.\nA unit. This is primarily stored in the <code>.debug_info</code> …\nA table of units. These are primarily stored in the …\nReturn the DWARF version for this line program.\nReturn the DWARF version for this unit.\nWrite a slice.\nWrite the DWARF information to the given sections.\nWrite the DWARf information to the given sections.\nWrite the line number program to the given section.\nWrite the string table to the <code>.debug_str</code> section.\nWrite the string table to the <code>.debug_str</code> section.\nWrite the units to the given sections.\nWrite an address.\nWrite a slice at a given offset.\nWrite the frame table entries to the given <code>.debug_frame</code> …\nWrite the frame table entries to the given <code>.eh_frame</code> …\nWrite an address with a <code>.eh_frame</code> pointer encoding.\nWrite a value with a <code>.eh_frame</code> pointer format.\nWrite an initial length according to the given DWARF …\nWrite an initial length at the given offset according to …\nWrite an offset that is relative to the start of the given …\nWrite an offset that is relative to the start of the given …\nWrite a reference to a symbol.\nWrite signed data of the given size.\nRead an unsigned LEB128 encoded integer.\nWrite a u16.\nWrite a u16 at the given offset.\nWrite a u32.\nWrite a u32 at the given offset.\nWrite a u64.\nWrite a u64 at the given offset.\nWrite a u8.\nWrite a u8 at the given offset.\nWrite unsigned data of the given size.\nWrite a word of the given size at the given offset.\nWrite an unsigned LEB128 encoded integer.\nGet the writer being used to write the section data.\nGet the writer being used to write the section data.\nThe offset of the address relative to the symbol.\nThe symbol that the address is relative to.\nBase address.\nStart of range relative to base address.\nStart of range.\nStart of range.\nLocation description.\nLocation description.\nLocation description.\nLocation description.\nEnd of range relative to base address.\nEnd of range.\nLength of range.\nBase address.\nStart of range relative to base address.\nStart of range.\nStart of range.\nEnd of range relative to base address.\nEnd of range.\nLength of range.\nFunction parameter or return value descriptor.\nAdd\nA value alias to original value.\nWhich disjoint region of aliasing memory is accessed in …\nAnd\nFunction argument extension options.\nThe special purpose of a function argument.\nAtomicCas(imms=(flags: ir::MemFlags), vals=3, blocks=0)\n<code>a = atomic_cas MemFlags, p, e, x</code>. (AtomicCas) Type …\n<code>a = atomic_load MemFlags, p</code>. (LoadNoOffset)\nAtomicRmw(imms=(flags: ir::MemFlags, op: ir::AtomicRmwOp), …\n<code>a = atomic_rmw MemFlags, AtomicRmwOp, p, x</code>. (AtomicRmw)\nDescribes the arithmetic operation in an atomic memory …\n<code>atomic_store MemFlags, x, p</code>. (StoreNoOffset) Type inferred …\n<code>a = avg_round x, y</code>. (Binary) Type inferred from <code>x</code>.\nAccess to a field via the wrong type.\n<code>a = band x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = band_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = band_not x, y</code>. (Binary) Type inferred from <code>x</code>.\nThe base part of a bound expression.\nBig-endian\nBinary(imms=(), vals=2, blocks=0)\nBinaryImm64(imms=(imm: ir::immediates::Imm64), vals=1, …\nBinaryImm8(imms=(imm: ir::immediates::Uimm8), vals=1, …\n<code>a = bitcast MemFlags, x</code>. (LoadNoOffset)\n<code>a = bitrev x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = bitselect c, x, y</code>. (Ternary) Type inferred from <code>x</code>.\nAn opaque reference to a basic block in a <code>Function</code>.\nA block header.\nA pair of a Block and its arguments, stored in a single …\nContents of a basic block.\n<code>a = bmask x</code>. (Unary)\n<code>a = bnot x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = bor x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = bor_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = bor_not x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>br_table x, JT</code>. (BranchTable)\nBranchTable(imms=(table: ir::JumpTable), vals=1, blocks=0)\nBrif(imms=(), vals=1, blocks=2)\n<code>brif c, block_then, block_else</code>. (Brif) Type inferred from <code>c</code>…\n<code>a = bswap x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = bxor x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = bxor_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = bxor_not x, y</code>. (Binary) Type inferred from <code>x</code>.\nCall(imms=(func_ref: ir::FuncRef), vals=0, blocks=0)\n<code>rvals = call FN, args</code>. (Call)\nCallIndirect(imms=(sig_ref: ir::SigRef), vals=1, blocks=0)\n<code>rvals = call_indirect SIG, callee, args</code>. (CallIndirect) …\n<code>a = ceil x</code>. (Unary) Type inferred from <code>x</code>.\nceil.f32\nceil.f64\n<code>a = cls x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = clz x</code>. (Unary) Type inferred from <code>x</code>.\nTLS index symbol for the current thread. Used in COFF/PE …\nA comparison result between two dynamic values with a …\nCondTrap(imms=(code: ir::TrapCode), vals=1, blocks=0)\nA “conflict fact”: this fact results from merging two …\nAn opaque reference to a constant.\nThis type describes the actual constant data. Note that …\nMaintains the mapping between a constant handle (i.e.  …\n<code>a = ctz x</code>. (Unary) Type inferred from <code>x</code>.\nA data flow graph defines all instructions and basic …\n<code>debugtrap</code>. (NullAry)\nA definition of a value to be used as a symbol in …\nValue is a multiple of how many instances of <code>vector_type</code> …\nA pointer to a memory type, dynamically bounded. The …\nA dynamically-sized untyped blob of memory, with bound …\nA value bounded by a global value.\n<code>addr = dynamic_stack_addr DSS</code>. (DynamicStackLoad)\nDynamicStackLoad(imms=(dynamic_stack_slot: …\n<code>a = dynamic_stack_load DSS</code>. (DynamicStackLoad)\nAn opaque reference to a dynamic stack slot.\nContents of a dynamic stack slot.\nAll allocated dynamic stack slots.\nDynamicStackStore(imms=(dynamic_stack_slot: …\n<code>dynamic_stack_store x, DSS</code>. (DynamicStackStore) Type …\nAn opaque reference to a dynamic type.\nA dynamic type object which has a base vector type and a …\nAll allocated dynamic types.\nELF well-known linker symbol <em>GLOBAL_OFFSET_TABLE</em>\nElf __tls_get_addr\nElf __tls_get_offset\nA type with no size.\nEndianness of a memory access.\nContains the error value\nAn explicit stack slot for dynamic vector types. This is a …\nAn explicit stack slot. This is a chunk of stack memory …\nA bound expression.\nAn external function.\nThe name of an external is either a reference to a …\n<code>a = extract_vector x, y</code>. (BinaryImm8) Type inferred from <code>x</code>.\n<code>a = extractlane x, Idx</code>. (BinaryImm8) Type inferred from <code>x</code>.\n<code>a = f128const N</code>. (UnaryConst)\n<code>a = f16const N</code>. (UnaryIeee16)\n<code>a = f32const N</code>. (UnaryIeee32)\n<code>a = f64const N</code>. (UnaryIeee64)\n<code>a = fabs x</code>. (Unary) Type inferred from <code>x</code>.\nA fact on a value.\nA “context” in which we can evaluate and derive facts. …\n<code>a = fadd x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fcmp Cond, x, y</code>. (FloatCompare) Type inferred from <code>x</code>.\n<code>a = fcopysign x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fcvt_from_sint x</code>. (Unary)\n<code>a = fcvt_from_uint x</code>. (Unary)\n<code>a = fcvt_to_sint x</code>. (Unary)\n<code>a = fcvt_to_sint_sat x</code>. (Unary)\n<code>a = fcvt_to_uint x</code>. (Unary)\n<code>a = fcvt_to_uint_sat x</code>. (Unary)\n<code>a = fdemote x</code>. (Unary)\n<code>a = fdiv x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>fence</code>. (NullAry)\nFloatCompare(imms=(cond: ir::condcodes::FloatCC), vals=2, …\n<code>a = floor x</code>. (Unary) Type inferred from <code>x</code>.\nfloor.f32\nfloor.f64\n<code>a = fma x, y, z</code>. (Ternary) Type inferred from <code>y</code>.\nfma.f32\nfma.f64\n<code>a = fmax x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fmin x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fmul x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fneg x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = fpromote x</code>. (Unary)\n<code>a = fsub x, y</code>. (Binary) Type inferred from <code>x</code>.\nFuncAddr(imms=(func_ref: ir::FuncRef), vals=0, blocks=0)\n<code>addr = func_addr FN</code>. (FuncAddr)\nAn opaque reference to another <code>Function</code>.\nFunctions can be cloned, but it is not a very fast …\n<code>a = fvdemote x</code>. (Unary)\n<code>x = fvpromote_low a</code>. (Unary)\n<code>addr = get_frame_pointer</code>. (NullAry)\n<code>addr = get_pinned_reg</code>. (NullAry)\n<code>addr = get_return_address</code>. (NullAry)\n<code>addr = get_stack_pointer</code>. (NullAry)\nAn opaque reference to a global value.\n<code>a = global_value GV</code>. (UnaryGlobalValue)\nA global value.\nInformation about a global value declaration.\nValue is an offset from another global value.\n<code>a = iabs x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = iadd x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = iadd_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = iadd_pairwise x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = icmp Cond, x, y</code>. (IntCompare) Type inferred from <code>x</code>.\n<code>a = icmp_imm Cond, x, Y</code>. (IntCompareImm) Type inferred …\n<code>a = iconcat lo, hi</code>. (Binary) Type inferred from <code>lo</code>.\n<code>a = iconst N</code>. (UnaryImm)\nAn opaque reference to an immediate.\n<code>a = imul x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = imul_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = ineg x</code>. (Unary) Type inferred from <code>x</code>.\nBuilder that inserts an instruction at the current …\n<code>a = insertlane x, y, Idx</code>. (TernaryImm8) Type inferred from …\nAn opaque reference to an instruction in a <code>Function</code>.\nAn instruction in the function.\nConvenience methods for building instructions.\nBase trait for instruction builders.\nBase trait for instruction inserters.\nIntAddTrap(imms=(code: ir::TrapCode), vals=2, blocks=0)\nIntCompare(imms=(cond: ir::condcodes::IntCC), vals=2, …\nIntCompareImm(imms=(cond: ir::condcodes::IntCC, imm: …\nAccess to an invalid or undefined field offset in a struct.\nStore of data to a field with a fact that does not subsume …\n<code>a = ireduce x</code>. (Unary)\n<code>a = irsub_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = ishl x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = ishl_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>lo, hi = isplit x</code>. (Unary) Type inferred from <code>x</code>.\n<code>istore16 MemFlags, x, p, Offset</code>. (Store) Type inferred …\n<code>istore32 MemFlags, x, p, Offset</code>. (Store) Type inferred …\n<code>istore8 MemFlags, x, p, Offset</code>. (Store) Type inferred from …\n<code>a = isub x, y</code>. (Binary) Type inferred from <code>x</code>.\nJump(imms=(), vals=0, blocks=1)\n<code>jump block_call</code>. (Jump)\nAn opaque reference to a jump table.\nContents of a jump table.\nMap of jump tables.\nA well-known symbol.\nA well-known symbol.\nThe <code>Layout</code> struct determines the layout of blocks and …\nThe name of a runtime library routine.\nA well-known runtime library function.\nLittle-endian\nLoad(imms=(flags: ir::MemFlags, offset: …\nValue is pointed to by another global value.\n<code>a = load MemFlags, p, Offset</code>. (Load)\nLoadNoOffset(imms=(flags: ir::MemFlags), vals=1, blocks=0)\nTop of the address space. This is “saturating”: the …\nA pointer to a memory type.\nFlags for memory operations like load/store.\nlibc.memcmp\nlibc.memcpy\nlibc.memmove\nA statically-sized untyped blob of memory.\nAn opaque reference to a memory type.\nData defining a memory type.\nOne field in a memory type.\nlibc.memset\nAn input to an operator that produces a fact-annotated …\nMultiAry(imms=(), vals=0, blocks=0)\nNand\n<code>a = nearest x</code>. (Unary) Type inferred from <code>x</code>.\nnearest.f32\nnearest.f64\nNo extension, high bits are indeterminate.\nNo dynamic part (i.e., zero).\n<code>nop</code>. (NullAry)\nA normal user program value passed to or from a function.\nNullAry(imms=(), vals=0, blocks=0)\nContains the success value\nAn instruction opcode.\nOr\nA memory access is out of bounds.\nAn operation wraps around, invalidating the stated value …\nValue is the n’th parameter to a block.\nAn error or inconsistency discovered when checking …\nThe result of checking proof-carrying-code facts.\n<code>a = popcnt x</code>. (Unary) Type inferred from <code>x</code>.\nprobe for stack overflow. These are emitted for functions …\nA <code>ProgramPoint</code> represents a position in a function where …\nA bitslice of a value (up to a bitwidth) is within the …\nSource location relative to another base source location.\nInstruction builder that replaces an existing instruction.\nValue is the n’th result of an instruction.\n<code>return rvals</code>. (MultiAry)\n<code>return_call FN, args</code>. (Call)\n<code>return_call_indirect SIG, callee, args</code>. (CallIndirect) …\n<code>a = rotl x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = rotl_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = rotr x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = rotr_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a, of = sadd_overflow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a, c_out = sadd_overflow_cin x, y, c_in</code>. (Ternary) Type …\n<code>a = sadd_sat x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = scalar_to_vector s</code>. (Unary)\n<code>a = sdiv x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = sdiv_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = select c, x, y</code>. (Ternary) Type inferred from <code>x</code>.\n<code>a = select_spectre_guard c, x, y</code>. (Ternary) Type inferred …\n<code>set_pinned_reg addr</code>. (Unary) Type inferred from <code>addr</code>.\nSigned extension: high bits in register replicate sign bit.\n<code>a = sextend x</code>. (Unary)\nShuffle(imms=(imm: ir::Immediate), vals=2, blocks=0)\n<code>a = shuffle a, b, mask</code>. (Shuffle)\nAn opaque reference to a function <code>Signature</code>.\nFunction signature.\n<code>a = sload16 MemFlags, p, Offset</code>. (Load)\n<code>a = sload16x4 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = sload32 MemFlags, p, Offset</code>. (Load) Type inferred from …\n<code>a = sload32x2 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = sload8 MemFlags, p, Offset</code>. (Load)\n<code>a = sload8x8 MemFlags, p, Offset</code>. (Load) Type inferred …\nSigned max\n<code>a = smax x, y</code>. (Binary) Type inferred from <code>x</code>.\nSigned min\n<code>a = smin x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a, of = smul_overflow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = smulhi x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = snarrow x, y</code>. (Binary) Type inferred from <code>x</code>.\nA source location.\n<code>a = splat x</code>. (Unary)\n<code>a = sqmul_round_sat x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = sqrt x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = srem x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = srem_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = sshr x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = sshr_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a, of = ssub_overflow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a, b_out = ssub_overflow_bin x, y, b_in</code>. (Ternary) Type …\n<code>a = ssub_sat x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>addr = stack_addr SS, Offset</code>. (StackLoad)\nStackLoad(imms=(stack_slot: ir::StackSlot, offset: …\n<code>a = stack_load SS, Offset</code>. (StackLoad)\nAn opaque reference to a stack slot.\nContents of a stack slot.\nThe kind of a stack slot.\nAll allocated stack slots.\nStackStore(imms=(stack_slot: ir::StackSlot, offset: …\n<code>stack_store x, SS, Offset</code>. (StackStore) Type inferred from …\n…\nOriginal value labels assigned at transform.\nStore(imms=(flags: ir::MemFlags, offset: …\n<code>store MemFlags, x, p, Offset</code>. (Store) Type inferred from <code>x</code>.\nStoreNoOffset(imms=(flags: ir::MemFlags), vals=2, blocks=0)\nAn aggregate consisting of certain fields at certain …\nA C struct passed as argument.\nStruct return pointer.\nSub\n<code>a = swiden_high x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = swiden_low x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = swizzle x, y</code>. (Binary)\nValue is symbolic, meaning it’s a name which will be …\n<code>a = symbol_value GV</code>. (UnaryGlobalValue)\nTernary(imms=(), vals=3, blocks=0)\nTernaryImm8(imms=(imm: ir::immediates::Uimm8), vals=2, …\nA test case function name of up to a hardcoded amount of …\nA name for a test case, mostly intended for Cranelift …\n<code>a = tls_value GV</code>. (UnaryGlobalValue)\nTrap(imms=(code: ir::TrapCode), vals=0, blocks=0)\n<code>trap code</code>. (Trap)\nA trap code describing the reason for a trap.\n<code>trapnz c, code</code>. (CondTrap) Type inferred from <code>c</code>.\n<code>trapz c, code</code>. (CondTrap) Type inferred from <code>c</code>.\n<code>a = trunc x</code>. (Unary) Type inferred from <code>x</code>.\ntrunc.f32\nfrunc.f64\nThe type of an SSA value.\n<code>a, of = uadd_overflow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a, c_out = uadd_overflow_cin x, y, c_in</code>. (Ternary) Type …\n<code>a = uadd_overflow_trap x, y, code</code>. (IntAddTrap) Type …\n<code>a = uadd_sat x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = udiv x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = udiv_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\nUnsigned extension: high bits in register are 0.\n<code>a = uextend x</code>. (Unary)\n<code>a = uload16 MemFlags, p, Offset</code>. (Load)\n<code>a = uload16x4 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = uload32 MemFlags, p, Offset</code>. (Load) Type inferred from …\n<code>a = uload32x2 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = uload8 MemFlags, p, Offset</code>. (Load)\n<code>a = uload8x8 MemFlags, p, Offset</code>. (Load) Type inferred …\nUnsigned max\n<code>a = umax x, y</code>. (Binary) Type inferred from <code>x</code>.\nUnsigned min\n<code>a = umin x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a, of = umul_overflow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = umulhi x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = unarrow x, y</code>. (Binary) Type inferred from <code>x</code>.\nUnary(imms=(), vals=1, blocks=0)\nUnaryConst(imms=(constant_handle: ir::Constant), vals=0, …\nUnaryGlobalValue(imms=(global_value: ir::GlobalValue), …\nUnaryIeee16(imms=(imm: ir::immediates::Ieee16), vals=0, …\nUnaryIeee32(imms=(imm: ir::immediates::Ieee32), vals=0, …\nUnaryIeee64(imms=(imm: ir::immediates::Ieee64), vals=0, …\nUnaryImm(imms=(imm: ir::immediates::Imm64), vals=0, …\nProof-carrying-code checking is not implemented for a …\nProof-carrying-code checking is not implemented for a …\nValue is a union of two other values.\nA block parameter claims a fact that one of its …\nA derivation of an output fact is unsupported (incorrect or\n<code>a = urem x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = urem_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\nA user-defined name, with semantics left to the user.\nA reference to a name in a user-defined symbol table.\nAn external name in a user-defined symbol table.\nA reference to an <code>UserExternalName</code>, declared with …\nAn explicit name for a user-defined function, be it …\nA compiled stack map, describing the location of many …\nA stack map entry describes a single GC-managed value and …\n<code>a = ushr x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = ushr_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a, of = usub_overflow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a, b_out = usub_overflow_bin x, y, b_in</code>. (Ternary) Type …\n<code>a = usub_sat x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = uunarrow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = uwiden_high x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = uwiden_low x</code>. (Unary) Type inferred from <code>x</code>.\nA VM context pointer.\nValue is the address of the VM context struct.\n<code>s = vall_true a</code>. (Unary) Type inferred from <code>a</code>.\nAn opaque reference to an SSA value.\nAn SSA Value as a symbolic value. This can be referenced in\nWhere did a value come from?\nMarked with a label value.\nValue label assignments: label starts or value aliases.\nA label of a Value.\nSome instructions use an external list of argument values …\nMemory pool for holding value lists. See <code>ValueList</code>.\n<code>s = vany_true a</code>. (Unary) Type inferred from <code>a</code>.\nA variable list of <code>Value</code> operands used for function call …\n<code>a = vconst N</code>. (UnaryConst)\n<code>x = vhigh_bits a</code>. (Unary)\nStore to a read-only field.\n<code>a = x86_blendv c, x, y</code>. (Ternary) Type inferred from <code>x</code>.\n<code>a = x86_cvtt2dq x</code>. (Unary)\n<code>a = x86_pmaddubsw x, y</code>. (Binary)\n<code>a = x86_pmulhrsw x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = x86_pshufb x, y</code>. (Binary)\nThe <code>pshufb</code> on x86 when SSSE3 isn’t available.\nExchange\nXor\nComputes whatever fact can be known about the sum of two …\nInserts a <code>ValueLabelAssignments::Alias</code> for <code>to_alias</code> if …\nAlignment of stack slot as a power-of-two exponent (log2 …\nGet the alignment in bytes of this stack slot given the …\nReturns a slice with all supported AtomicRmwOp’s.\nAll cranelift opcodes.\nGet a list of all known <code>LibCall</code>’s.\nReturn information about a call instruction.\nAdd new bytes to the constant data.\nAppend an argument to the block args.\nInsert <code>block</code> as the last block in the layout.\nAppend a parameter with type <code>ty</code> to <code>block</code>.\nSimilar to <code>append_block_param</code>, append a parameter with …\nAppend <code>inst</code> to the end of <code>block</code>.\nAppend a new stack map entry for the given call …\nApply a known inequality to rewrite dynamic bounds using …\nReturn a slice for the arguments of this block.\nReturn a slice for the arguments of this block.\nGet the value arguments to this instruction.\nGet mutable references to the value arguments to this …\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nReturn the raw bit encoding for this instance.\nIs this a constant value of the given bitwidth? Return it …\nReturn the data as a slice.\nIs this fact a single-value range with a symbolic Expr?\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nReturn the underlying index value as a <code>u32</code>.\nPerform an atomic compare-and-swap operation on memory at <code>p</code>…\nAtomically load from memory at <code>p</code>.\nAtomically read-modify-write memory at <code>p</code>, with second …\nIf this is an atomic read/modify/write instruction, return …\nAtomically store <code>x</code> to memory at <code>p</code>.\nAppend an existing value to <code>block</code>’s parameters.\nUnsigned average with rounding: <code>a := (x + y + 1) // 2</code>\nBitwise and.\nBitwise and with immediate.\nBitwise and not.\nThe dynamic (base) part.\nBase vector type, this is the minimum size of the type.\nReinterpret the bits in <code>x</code> as a different type.\nReverse the bits of a integer.\nRead the bits of this source location.\nConditional select of bits.\nReturn the block for this BlockCall.\nMake a BlockCall, bundling together the block and its …\nReturns the capacity of the <code>BlockData</code> map.\nIterate over the instructions in <code>block</code> in layout order.\nReturns <code>true</code> if the given block reference is valid.\nGet the types of the parameters on <code>block</code>.\nGet the parameters on <code>block</code>.\nReturn an iterator over all blocks in layout order.\nbasic blocks in the function and their parameters.\nConvert <code>x</code> to an integer mask.\nBitwise not.\nBitwise or.\nBitwise or with immediate.\nBitwise or not.\nIndirect branch via jump table.\nGet the destinations of this instruction, if it’s a …\nGet a mutable slice of the destinations of this …\nConditional branch when cond is non-zero.\nReverse the byte order of an integer.\nInsert an instruction and return a reference to it, …\nBitwise xor.\nBitwise xor with immediate.\nBitwise xor not.\nReturn the combined size of all of the constant values in …\nDirect function call.\nCalling convention.\nIndirect function call.\nGet the call signature of a direct or indirect call …\nCan this instruction read from memory?\nCan this instruction write to memory?\nCan this instruction cause a trap?\nRound floating point round to integral, towards positive …\nTurn a value into an alias of another.\nCheck that the given concrete <code>Type</code> has been defined in the …\nEmpty the constant pool of all data.\nClear everything.\nClear all data structures in this function.\nClear out the arguments list.\nClear the layout.\nClear the list of result values from <code>inst</code>.\nClone an instruction, attaching new result <code>Value</code>s and …\nCount leading sign bits.\nCount leading zero bits.\nStarts collection of debug information.\nWill this function be defined nearby, such that it will …\nCompute the type of an instruction result from opcode …\nConvert ‘base_vector_ty’ into a concrete dynamic …\nIf this is a control-flow instruction depending on an …\nCondition codes for the Cranelift code generator.\nConstants\nCreate a range fact that specifies a single known constant …\nConstant value.\nConstants used within the function.\nGet the constraint descriptor for this opcode. Panic if …\nGet the controlling type variable, or <code>INVALID</code> if <code>inst</code> isn…\nCount trailing zeros.\nGet an immutable reference to the data flow graph that …\nGet an immutable reference to the data flow graph.\nGet a mutable reference to the data flow graph that will …\nGet a mutable reference to the data flow graph.\nEncodes an assembly debug trap.\nDeclare a user-defined external function import, to be …\nDeep-clone the underlying list in the same pool. The …\nDeep-clone an <code>InstructionData</code>, including any referenced …\nDetach all the parameters from <code>block</code> and return them as a …\nData flow graph tracking Instructions, Values, and blocks.\nReturn an object that can display this function with …\nReturn a value that can display this block call.\nReturns an object that displays <code>inst</code>.\nReturns an object that displays the given <code>value</code>’s …\nThe type of this slot.\nCreate a dynamic range fact that points to the base of a …\nThe dynamic scaling factor of the base vector type.\nGet the address of a dynamic stack slot.\nLoad a value from a dynamic stack slot.\nStore a value to a dynamic stack slot.\nConvert a dynamic-vector type to a fixed-vector type.\nDynamic IR types\nDynamic types created.\nCranelift IR entity references.\nIterate over the entries in this stack map.\nIterate over mutable entries in the constant pool in …\nGet the function’s entry block. This is simply the first …\nCompare two <code>InstructionData</code> for equality.\nExpands the relative source location into an absolute one, …\nExpand the size of the constant data to <code>expected_size</code> …\nExternal function references. These are functions that can …\nAppends multiple elements to the arguments.\nMethod for extending argument to a full register.\nReturn a fixed length sub vector, extracted from a dynamic …\nExtract lane <code>Idx</code> from <code>x</code>.\nFloating point constant.\nFloating point constant.\nFloating point constant.\nFloating point constant.\nFloating point absolute value.\nGet the fact, if any, on a field.\nA proof-carrying-code fact about this value, if any.\nFacts: proof-carrying-code assertions about values.\nFloating point addition.\nFloating point comparison.\nFloating point copy sign.\nConvert signed integer to floating point.\nConvert unsigned integer to floating point.\nConverts floating point scalars to signed integer.\nConvert floating point to signed integer as fcvt_to_sint …\nConverts floating point scalars to unsigned integer.\nConvert floating point to unsigned integer as fcvt_to_uint …\nConvert <code>x</code> to a smaller floating point format.\nFloating point division.\nA memory fence.  This must provide ordering to ensure …\nFetch a block’s first instruction.\nGet the first result of an instruction.\nRound floating point round to integral, towards negative …\nFloating point fused multiply-and-add.\nFloating point maximum, propagating NaNs using the …\nFloating point minimum, propagating NaNs using the …\nPrint the constant data in hexadecimal format, e.g. …\nFloating point multiplication.\nFloating point negation.\nGet the instruction format for this opcode.\nIf this is a control-flow instruction depending on a …\nConvert <code>x</code> to a larger floating point format.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSource location when it is in effect\nCreates a new <code>RelSourceLoc</code> based on the given base and …\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from the raw bit encoding.\nParse a hexadecimal string to <code>ConstantData</code>. This is the …\nParse an Opcode name from a string.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nCreate a new instance from a <code>u32</code>.\nFloating point subtraction.\nGet the address of a function.\nIntermediate representation of a function.\nConvert <code>x</code> to a smaller floating point format.\nConverts packed single precision floating point to packed …\nRetrieve the constant data given a handle.\nGet the address in the frame pointer register.\nGets the content of the pinned register, when it’s …\nGet a function reference for the probestack function in …\nGet the PC where this function will transfer control to …\nGet the address in the stack pointer register.\nGet a <code>UserExternalName</code> if this is a user-defined name.\nCompute the value of global GV.\nCreate a fact that specifies the value is exactly the …\nThe value of a global value.\nCreate a fact that specifies the value is exactly the …\nTest if <code>inst</code> has any result values currently.\nHash an <code>InstructionData</code>.\nInteger absolute value with wrapping: <code>a := |x|</code>.\nWrapping integer addition: <code>a := x + y \\pmod{2^B}</code>.\nAdd immediate integer.\nDoes lane-wise integer pairwise addition on two operands, …\nInteger comparison.\nCompare scalar integer to a constant.\nConcatenate low and high bits to form a larger integer …\nInteger constant.\nImmediate operands for Cranelift instructions\nStores large immediates that otherwise will not fit on …\nDeclare an external function import.\nWrapping integer multiplication: <code>a := x y \\pmod{2^B}</code>.\nInteger multiplication by immediate constant.\nArbitrary.\nInteger negation: <code>a := -x \\pmod{2^B}</code>.\nTry to infer a minimal fact for a value of the given IR …\nInsert constant data into the pool, returning a handle for …\nInsert <code>block</code> in the layout before the existing block <code>before</code>…\nInsert <code>block</code> in the layout <em>after</em> the existing block <code>after</code>.\nInsert a new instruction which belongs to the DFG.\nInsert <code>inst</code> before the instruction <code>before</code> in the same …\nInsert <code>y</code> as lane <code>Idx</code> in x.\nGet the instruction where the value was defined, if any.\nGet all value arguments on <code>inst</code> as a slice.\nGet all value arguments on <code>inst</code> as a mutable slice.\nGet the block containing <code>inst</code>, or <code>None</code> if <code>inst</code> is not …\nGet the fixed value arguments on <code>inst</code> as a slice.\nGet the fixed value arguments on <code>inst</code> as a mutable slice.\nReturns <code>true</code> if the given instruction reference is valid.\nGet the result types of the given instruction.\nReturn all the results of an instruction.\nReturn all the results of an instruction as ValueList.\nConstruct a read-only visitor context for the values of …\nGet the variable value arguments on <code>inst</code> as a slice.\nGet the variable value arguments on <code>inst</code> as a mutable …\nInstruction formats and opcodes.\nData about all of the instructions in the function, …\nMerge two facts. We take the <em>intersection</em>: that is, we know\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert this to a value list in <code>pool</code> with <code>fixed</code> prepended.\nConvert the data to a vector.\nConvert <code>x</code> to a smaller integer type by discarding the most …\nImmediate reverse wrapping subtraction: …\nIs <code>block</code> currently part of the layout?\nTrue for all branch or jump instructions.\nIs this a call instruction?\nIs the given block cold?\nIs this the default source location?\nIs this the default relative source location?\nCheck if the constant contains any bytes.\nCheck if the list is empty.\nIs this a return instruction?\nIs this instruction a GC safepoint?\nDoes this dynamic_expression take an offset?\nTrue for instructions that terminate the block\nInteger shift left. Shift the bits in <code>x</code> towards the MSB by …\nInteger shift left by immediate.\nSplit an integer into low and high parts.\nStore the low 16 bits of <code>x</code> to memory at <code>p + Offset</code>.\nStore the low 32 bits of <code>x</code> to memory at <code>p + Offset</code>.\nStore the low 8 bits of <code>x</code> to memory at <code>p + Offset</code>.\nWrapping integer subtraction: <code>a := x - y \\pmod{2^B}</code>.\nIterate over the constant’s bytes.\nIterate over the constants in insertion order.\nJump.\nJump tables used in this function.\nJump table representation.\nThe kind of stack slot.\nThe kind of stack slot.\nThe label index.\nGet the last block in the layout.\nFetch a block’s last instruction.\nFunction layout.\nReturn the number of bytes in the constant.\nReturn the number of constants in the pool.\nCheck a load, and determine what fact, if any, the result …\nLoad from memory at <code>p + Offset</code>.\nIf this is a load/store instruction, returns its immediate …\nCreate a new basic block.\nDeclares a dynamic vector type\nCreate a new instruction.\nCreate result values for an instruction that produces …\nCreate result values for <code>inst</code>, reusing the provided …\nCreate result values for <code>inst</code>, reusing the provided …\nCreate an invalid value, to pad the index space. This is …\nCreate a new value alias. This is only for use by the …\nMap a function over the values of the instruction.\nReplace the values used in this instruction according to …\nCreate a range fact that specifies the maximum range for a …\nCreate a range fact that specifies the maximum range for a …\nIf this is a load/store instruction, return its memory …\nMerge the facts for two values. If both values have facts …\nName of the external function.\nName of this function.\nArbitrary.\nRound floating point round to integral, towards nearest …\nCreate a new builder which inserts instructions at <code>pos</code>. …\nCreate a <code>ReplaceBuilder</code> that will overwrite <code>inst</code>.\nCreate a new “fact context” in which to evaluate facts.\nCreate a new constant pool instance.\nCreate a new empty <code>DataFlowGraph</code>.\nCreate a new dynamic type.\nCreates a new UserExternalName.\nCreate a new empty, anonymous function with a Fast calling …\nConstruct a BlockCall with the given block and arguments.\nCreate an empty argument list.\nCreate a new empty <code>Layout</code>.\nCreate a new source location with the given bits.\nCreate a new relative source location with the given bits.\nCreate a stack slot with the specified byte size.\nGet the block following <code>block</code> in the layout order.\nFetch the instruction following <code>inst</code>.\nJust a dummy instruction.\nGet the number component of this definition.\nGet the number of parameters on <code>block</code>.\nGet the total number of basic blocks created in this …\nGet the total number of instructions created in this …\nGet the total number of values.\nOffsets a value with a fact by a known amount.\nAdd a static offset to an expression.\nThe offset of this field in the memory type.\nThe static (offset) part.\nThe offset within the stack slot where this entry’s …\nGet the opcode of this instruction.\nDoes this instruction have other side effects besides can_*…\nOverwrite the instruction’s value references with values …\nGet the parameters on <code>block</code>.\nThe arguments passed to the function.\nAll the parameters that can be applied onto the function …\nProof-carrying code. We attach “facts” to values and …\nPopulation count\nGet the block containing the program point <code>pp</code>. Panic if <code>pp</code> …\nCompare the program points <code>a</code> and <code>b</code> in the same block …\nGet the block preceding <code>block</code> in the layout order.\nFetch the instruction preceding <code>inst</code>.\nDoes this fact “propagate” automatically, i.e., cause …\nSpecial purpose of argument, or <code>Normal</code>.\nAdd an argument to the end.\nWhether this field is read-only, i.e., stores should be …\nRemove the argument at ix from the argument list.\nRemove <code>block</code> from the layout.\nRemoves <code>val</code> from <code>block</code>‘s parameters by a standard linear …\nRemove <code>inst</code> from the layout.\nCreate a <code>ReplaceBuilder</code> that will replace <code>inst</code> with a new …\nReplace a block parameter with a new value of type <code>ty</code>.\nReplace an instruction result with a new value of type …\nReplace the results of one instruction with aliases to the …\nResolve value aliases.\nReplace all uses of value aliases with their resolved …\nReturn from the function.\nDirect tail call.\nIndirect tail call.\nValues returned from the function.\nRotate left.\nRotate left by immediate.\nRotate right.\nRotate right by immediate.\nAdd integers signed with overflow out. <code>of</code> is set when the …\nAdd signed integers with carry in and overflow out.\nAdd with signed saturation.\nCopies a scalar value to a vector value.  The scalar is …\nScales a value with a fact by a known constant.\nSigned integer division rounded toward zero: …\nSigned integer division by an immediate constant.\nConditional select.\nConditional select intended for Spectre guards.\nLink a constant handle to its value. This does not …\nCompute the type of an alias. This is only for use in the …\nReplace the block for this BlockCall.\nMark a block as “cold”.\nSets the content of the pinned register, when it’s …\nSets an absolute source location for the given instruction.\nComputes the <code>sextend</code> of a value with the given facts.\nConvert <code>x</code> to a larger integer type by sign-extending.\nLeft-shifts a value with a fact by a known constant.\nSIMD vector shuffle.\nDespite having side effects, is this instruction okay to …\nGet a Signature for the function targeted by this LibCall.\nCall signature of function.\nFunction signature table. These signatures are referenced …\nSize of stack slot in bytes.\nLoad 16 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad a 16x4 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad 32 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad a 32x2 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad 8 bits from memory at <code>p + Offset</code> and sign-extend.\nLoad an 8x8 vector (64 bits) from memory at <code>p + Offset</code> and …\nThe stack slot that this stack map entry is within.\nSigned integer maximum.\nSigned integer minimum.\nMultiply integers signed with overflow out. <code>of</code> is set when …\nSigned integer multiplication, producing the high half of a\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nVector splat.\nSplit the block containing <code>before</code> in two.\nFixed-point multiplication of numbers in the QN format, …\nFloating point square root.\nReturns an absolute source location for the given …\nSigned integer remainder. The result has the sign of the …\nSigned integer remainder with immediate divisor.\nSigned shift right. Shift bits in <code>x</code> towards the LSB by <code>y</code> …\nSigned shift right by immediate.\nSubtract integers signed with overflow out. <code>of</code> is set when …\nSubtract signed integers with borrow in and overflow out.\nSubtract with signed saturation.\nGet the address of a stack slot.\nLoad a value from a stack slot at the constant offset.\nIf this instruction references a stack slot, return it\nStore a value to a stack slot at a constant offset.\nSuspends execution of the current stack and resumes …\nStack slots.\nProvide the static size of this type, if known.\nAll the fields required for compiling a function, …\nCheck a store.\nStore <code>x</code> to memory at <code>p + Offset</code>.\nGet the access struct field, if any, by a pointer with the …\nComputes whether <code>lhs</code> “subsumes” (implies) <code>rhs</code>.\nComputes whether the optional fact <code>lhs</code> subsumes (implies) …\nRemoves <code>val</code> from <code>block</code>’s parameters by swapping it with …\nWiden the high lanes of <code>x</code> using signed extension.\nWiden the low lanes of <code>x</code> using signed extension.\nVector swizzle.\nCompute the value of global GV, which is a symbolic value.\nCreates a new external name from a sequence of bytes. …\nCompute the value of global GV, which is a TLS (thread …\nTerminate execution unconditionally.\nIf this is a trapping instruction, get its trap code. …\nIf this is a trapping instruction, get an exclusive …\nTrap when non-zero.\nTrap when zero.\nRound floating point round to integral, towards zero.\nComputes the bit-truncation of a value with the given fact.\nThe primitive type of the value in this field. Accesses to …\nThe type of the value stored in this stack map entry.\nCommon types for the Cranelift code generator.\nGet the controlling type variable operand.\nAdd integers unsigned with overflow out. <code>of</code> is set when …\nAdd unsigned integers with carry in and overflow out.\nUnsigned addition of x and y, trapping if the result …\nAdd with unsigned saturation.\nUnsigned integer division: <code>a := \\lfloor {x \\over y} \\rfloor</code>…\nUnsigned integer division by an immediate constant.\nComputes the <code>uextend</code> of a value with the given facts.\nConvert <code>x</code> to a larger integer type by zero-extending.\nLoad 16 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad a 16x4 vector (64 bits) from memory at <code>p + Offset</code> and …\nLoad 32 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad an 32x2 vector (64 bits) from memory at <code>p + Offset</code> …\nLoad 8 bits from memory at <code>p + Offset</code> and zero-extend.\nLoad an 8x8 vector (64 bits) from memory at <code>p + Offset</code> and …\nUnsigned integer maximum.\nUnsigned integer minimum.\nMultiply integers unsigned with overflow out. <code>of</code> is set …\nUnsigned integer multiplication, producing the high half …\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nCompute the union of two facts, if possible.\nCreate a union of two values.\nUnwrap the block there the parameter is defined, or panic.\nUnwrap the instruction where the value was defined, or …\nGet the instruction we know is inside.\nUnsigned integer remainder.\nUnsigned integer remainder with immediate divisor.\nCreate a new external name from a user-defined external …\nGet the stack map entries associated with the given …\nUnsigned shift right. Shift bits in <code>x</code> towards the LSB by <code>y</code> …\nUnsigned shift right by immediate.\nSubtract integers unsigned with overflow out. <code>of</code> is set …\nSubtract unsigned integers with borrow in and overflow out.\nSubtract with unsigned saturation.\nCombine <code>x</code> and <code>y</code> into a vector with twice the lanes but …\nWiden the high lanes of <code>x</code> using unsigned extension.\nWiden the low lanes of <code>x</code> using unsigned extension.\nReduce a vector to a scalar boolean.\nCreate a fact that specifies the value is exactly an SSA …\nThe value of an SSA value.\nIf <code>v</code> is already defined as an alias, return its …\nGet the definition of a value.\nDetermine if <code>v</code> is an attached instruction result / block …\nCheck whether a value is valid and not an alias.\nCheck if a value reference is valid.\nCheck if a value reference is valid, while being aware of …\nMemory pool of value lists.\nCreate a fact that specifies the value is exactly an SSA …\nGet the type of a value.\nType of the argument value.\nGet an iterator over all values.\nGet an iterator over all values and their definitions.\nSaves Value labels.\nReduce a vector to a scalar boolean.\nSIMD vector constant.\nReduce a vector to a scalar integer.\nCreate a function with the given name and signature.\nCreate a new stack slot reference from its number.\nCreate a new stack slot reference from its number.\nCreate a new dynamic type reference from its number.\nCreate a new global value reference from its number.\nCreate a new memory type reference from its number.\nCreate a const reference from its number.\nCreate an immediate reference from its number.\nCreate a new jump table reference from its number.\nCreate a new external function reference from its number.\nCreate a new function signature reference from its number.\nReuse a single result value.\nReuse result values in <code>reuse</code>.\nIs this Expr a BaseExpr with no offset? Return it if so.\nA bitselect-lookalike instruction except with the …\nA float-to-integer conversion instruction for …\nAn instruction with equivalent semantics to <code>pmaddubsw</code> on …\nA similar instruction to <code>sqmul_round_sat</code> except with the …\nA vector swizzle lookalike which has the semantics of …\nThe bitwidth of bits we care about, from the LSB upward.\nThe bitwidth of bits we care about, from the LSB upward.\nThe kind of comparison.\nThe left-hand side of the comparison.\nThe maximum value that the bitslice can take (inclusive). …\nThe upper bound, inclusive.\nThe upper bound, inclusive.\nThe maximum offset into the memory type, inclusive.\nThe minimum value that the bitslice can take (inclusive). …\nThe lower bound, inclusive.\nThe lower bound, inclusive.\nThe minimum offset into the memory type, inclusive.\nThis pointer can also be null.\nThis pointer can also be null.\nThe right-hand side of the comparison.\nThe memory type.\nThe memory type.\nThe SSA value this value defines.\nThe base pointer global value.\nThe base pointer global value.\nWill this symbol be defined nearby, such that it will …\nSpecifies the memory flags to be used by the load. …\nType of the loaded value.\nType of the iadd.\nThe symbolic name.\nOffset added to the base pointer before doing the load.\nByte offset to be added to the value.\nOffset from the symbol. This can be used instead of …\nDoes this symbol refer to a thread local storage value?\nBase vector type.\nFields in this type. Sorted by offset.\nDynamic part of size.\nSize of this type.\nAccessible size.\nStatic part of size.\nSource location when it is in effect\nThe label index.\nCommon traits of condition codes.\n<code>==</code>.\nEQ\nCondition code for comparing floating point numbers.\nGT\nGT | EQ\nCondition code for comparing integers.\nLT\nLT | EQ\n<code>!=</code>.\nThe C ‘!=’ operator is the inverse of ‘==’: …\nEQ | LT | GT\nLT | GT\nSigned <code>&gt;</code>.\nSigned <code>&gt;=</code>.\nSigned <code>&lt;</code>.\nSigned <code>&lt;=</code>.\nUN\nUN | EQ\nUN | GT\nUN | GT | EQ\nUN | LT\nUN | LT | EQ\nUnsigned <code>&gt;</code>.\nUnsigned <code>&gt;=</code>.\nUnsigned <code>&lt;</code>.\nUnsigned <code>&lt;=</code>.\nGet the complemented condition code of <code>self</code>.\nGet the swapped args condition code for <code>self</code>.\nThis type describes the actual constant data. Note that …\nMaintains the mapping between a constant handle (i.e.  …\nContents of a basic block.\nStorage for basic blocks within the DFG.\nA data flow graph defines all instructions and basic …\nObject that can display an instruction.\nStorage for instructions within the DFG.\nValue is the n’th parameter to a block.\nValue is the n’th result of an instruction.\nValue is a union of two other values.\nWhere did a value come from?\nIterator over all Values in a DFG.\nCreate a new basic block.\nbasic blocks in the function and their parameters.\nConstants used within the function.\nDynamic types created.\nExternal function references. These are functions that can …\nFacts: proof-carrying-code assertions about values.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nStores large immediates that otherwise will not fit on …\nData about all of the instructions in the function, …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the given block reference is valid.\nJump tables used in this function.\nGet the total number of basic blocks created in this …\nFunction signature table. These signatures are referenced …\nMemory pool of value lists.\nSaves Value labels.\nA dynamic type object which has a base vector type and a …\nAll allocated dynamic types.\nBase vector type, this is the minimum size of the type.\nThe dynamic scaling factor of the base vector type.\nConvert a dynamic-vector type to a fixed-vector type.\nAn opaque reference to any of the entities defined in this …\nAn opaque reference to a basic block in a <code>Function</code>.\na basic block.\nAn opaque reference to a constant.\nA constant.\nAn opaque reference to a dynamic stack slot.\nA dynamic stack slot.\nAn opaque reference to a dynamic type.\nA dynamic type\nAn opaque reference to another <code>Function</code>.\nAn external function.\nThe whole function.\nAn opaque reference to a global value.\nA Global value.\nAn opaque reference to an immediate.\nAn opaque reference to an instruction in a <code>Function</code>.\nAn instruction.\nAn opaque reference to a jump table.\nA jump table.\nAn opaque reference to a memory type.\nA memory type.\nAn opaque reference to a function <code>Signature</code>.\nA function call signature.\nA function’s stack limit\nAn opaque reference to a stack slot.\nA stack slot.\nA reference to an <code>UserExternalName</code>, declared with …\nAn opaque reference to an SSA value.\nAn SSA value.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWrapper type capable of displaying a <code>Function</code>.\nFunctions can be cloned, but it is not a very fast …\nFunction parameters used when creating this function, and …\nFunction fields needed when compiling a function.\nA version marker used to ensure that serialized clif ir is …\nReturns the base <code>SourceLoc</code>.\nReturns an iterator over the blocks succeeding the given …\nStarts collection of debug information.\nCreates a dynamic stack slot in the function, to be used …\nDeclares a global value accessible to the function.\nCreates a jump table in the function, to be used by …\nDeclares a memory type for use by the function.\nCreates a sized stack slot in the function, to be used by …\nData flow graph containing the primary definition of all …\nDynamic stack slots allocated in this function.\nSets the base <code>SourceLoc</code>, if not set yet, and returns the …\nRetrieve a <code>UserExternalNameRef</code> for the given name, or add …\nSize occupied by all stack slots associated with this …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet a concrete <code>Type</code> from a user defined <code>DynamicType</code>.\nFind the global dyn_scale value associated with given …\nFind the global dyn_scale for the given stack slot.\nGlobal value proof-carrying-code facts.\nGlobal values referenced.\nAdds a signature which can later be used to declare an …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks that the specified block can be encoded as a basic …\nReturns true if the function is function that doesn’t …\nLayout of blocks and instructions in the function body.\nMemory types for proof-carrying code.\nName of this function.\nCreates a new <code>FunctionParameters</code> with the given name.\nAll the parameters that can be applied onto the function …\nResets an already existing user function name to a new …\nRewrite the branch destination to <code>new_dest</code> if the …\nSignature of this function.\nSized stack slots allocated in this function.\nFind a presumed unique special-purpose function parameter …\nSource locations.\nAn optional global value which represents an expression …\nAll the fields required for compiling a function, …\nReplace the <code>dst</code> instruction’s data with the <code>src</code> …\nReturns the internal mapping of <code>UserExternalNameRef</code> to …\nA version marker used to ensure that serialized clif ir is …\nAn IEEE binary128 immediate floating point value, …\nAn IEEE binary16 immediate floating point value, …\nAn IEEE binary32 immediate floating point value, …\nAn IEEE binary64 immediate floating point value, …\n64-bit immediate signed integer operand.\nConvert a type into a vector of bytes; all implementors in …\nThe positive WebAssembly canonical NaN.\nThe positive WebAssembly canonical NaN.\n32-bit signed immediate offset.\nA 32-bit unsigned integer immediate operand.\n64-bit immediate unsigned integer operand.\n8-bit unsigned integer immediate operand.\nA 128-bit immediate operand.\nComputes the absolute value of <code>self</code>.\nComputes the absolute value of <code>self</code>.\nConvert the immediate into a slice.\nGet the bitwise representation.\nGet the bitwise representation.\nIterate over the bytes in the constant.\nReturns a number composed of the magnitude of <code>self</code> and the …\nReturns a number composed of the magnitude of <code>self</code> and the …\nCreate an <code>Ieee16</code> number representing the greatest negative …\nCreate an <code>Ieee128</code> number representing the greatest …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn the little-endian byte representation of the …\nCheck if the value is a NaN. For <code>Ieee16</code>, this means …\nCheck if the value is a NaN. For <code>Ieee128</code>, this means …\nReturns true if <code>self</code> has a negative sign, including -0.0, …\nReturns true if <code>self</code> has a negative sign, including -0.0, …\nReturns true if <code>self</code> has a negative sign, including 0.0, …\nReturns true if <code>self</code> has a negative sign, including 0.0, …\nReturns <code>true</code> if <code>self</code> is positive or negative zero.\nReturns <code>true</code> if <code>self</code> is positive or negative zero.\nReturns the maximum of <code>self</code> and <code>other</code>, following the …\nReturns the maximum of <code>self</code> and <code>other</code>, following the …\nReturns the minimum of <code>self</code> and <code>other</code>, following the …\nReturns the minimum of <code>self</code> and <code>other</code>, following the …\nCreate a new <code>Offset32</code> representing the signed number <code>x</code>.\nReturns <code>None</code> if <code>self</code> is a NaN and <code>Some(self)</code> otherwise.\nReturns <code>None</code> if <code>self</code> is a NaN and <code>Some(self)</code> otherwise.\nCreate an <code>Ieee16</code> number representing <code>2.0^n</code>.\nCreate an <code>Ieee128</code> number representing <code>2.0^n</code>.\nConvert the immediate into a vector.\nAdd in the signed number <code>x</code> if possible.\nCreate a new <code>Offset32</code> representing the signed number <code>x</code> if …\nCreate a new <code>Ieee16</code> containing the bits of <code>bits</code>.\nCreate a new <code>Ieee128</code> containing the bits of <code>bits</code>.\nAtomicCas(imms=(flags: ir::MemFlags), vals=3, blocks=0)\n<code>a = atomic_cas MemFlags, p, e, x</code>. (AtomicCas) Type …\n<code>a = atomic_load MemFlags, p</code>. (LoadNoOffset)\nAtomicRmw(imms=(flags: ir::MemFlags, op: ir::AtomicRmwOp), …\n<code>a = atomic_rmw MemFlags, AtomicRmwOp, p, x</code>. (AtomicRmw)\n<code>atomic_store MemFlags, x, p</code>. (StoreNoOffset) Type inferred …\n<code>a = avg_round x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = band x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = band_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = band_not x, y</code>. (Binary) Type inferred from <code>x</code>.\nBinary(imms=(), vals=2, blocks=0)\nBinaryImm64(imms=(imm: ir::immediates::Imm64), vals=1, …\nBinaryImm8(imms=(imm: ir::immediates::Uimm8), vals=1, …\n<code>a = bitcast MemFlags, x</code>. (LoadNoOffset)\n<code>a = bitrev x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = bitselect c, x, y</code>. (Ternary) Type inferred from <code>x</code>.\nA pair of a Block and its arguments, stored in a single …\n<code>a = bmask x</code>. (Unary)\n<code>a = bnot x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = bor x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = bor_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = bor_not x, y</code>. (Binary) Type inferred from <code>x</code>.\nThe operand is bound to a known type.\n<code>br_table x, JT</code>. (BranchTable)\nBranchTable(imms=(table: ir::JumpTable), vals=1, blocks=0)\nBrif(imms=(), vals=1, blocks=2)\n<code>brif c, block_then, block_else</code>. (Brif) Type inferred from <code>c</code>…\n<code>a = bswap x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = bxor x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = bxor_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = bxor_not x, y</code>. (Binary) Type inferred from <code>x</code>.\nCall(imms=(func_ref: ir::FuncRef), vals=0, blocks=0)\n<code>rvals = call FN, args</code>. (Call)\nCallIndirect(imms=(sig_ref: ir::SigRef), vals=1, blocks=0)\n<code>rvals = call_indirect SIG, callee, args</code>. (CallIndirect) …\nInformation about call instructions.\n<code>a = ceil x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = cls x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = clz x</code>. (Unary) Type inferred from <code>x</code>.\nCondTrap(imms=(code: ir::TrapCode), vals=1, blocks=0)\n<code>a = ctz x</code>. (Unary) Type inferred from <code>x</code>.\n<code>debugtrap</code>. (NullAry)\nThis is a direct call to an external function declared in …\nWrapper for the context needed to display a BlockCall …\n<code>addr = dynamic_stack_addr DSS</code>. (DynamicStackLoad)\nDynamicStackLoad(imms=(dynamic_stack_slot: …\n<code>a = dynamic_stack_load DSS</code>. (DynamicStackLoad)\nDynamicStackStore(imms=(dynamic_stack_slot: …\n<code>dynamic_stack_store x, DSS</code>. (DynamicStackStore) Type …\n<code>a = extract_vector x, y</code>. (BinaryImm8) Type inferred from <code>x</code>.\n<code>a = extractlane x, Idx</code>. (BinaryImm8) Type inferred from <code>x</code>.\n<code>a = f128const N</code>. (UnaryConst)\n<code>a = f16const N</code>. (UnaryIeee16)\n<code>a = f32const N</code>. (UnaryIeee32)\n<code>a = f64const N</code>. (UnaryIeee64)\n<code>a = fabs x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = fadd x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fcmp Cond, x, y</code>. (FloatCompare) Type inferred from <code>x</code>.\n<code>a = fcopysign x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fcvt_from_sint x</code>. (Unary)\n<code>a = fcvt_from_uint x</code>. (Unary)\n<code>a = fcvt_to_sint x</code>. (Unary)\n<code>a = fcvt_to_sint_sat x</code>. (Unary)\n<code>a = fcvt_to_uint x</code>. (Unary)\n<code>a = fcvt_to_uint_sat x</code>. (Unary)\n<code>a = fdemote x</code>. (Unary)\n<code>a = fdiv x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>fence</code>. (NullAry)\nFloatCompare(imms=(cond: ir::condcodes::FloatCC), vals=2, …\n<code>a = floor x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = fma x, y, z</code>. (Ternary) Type inferred from <code>y</code>.\n<code>a = fmax x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fmin x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fmul x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = fneg x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = fpromote x</code>. (Unary)\nThe operand type can vary freely within the given set.\n<code>a = fsub x, y</code>. (Binary) Type inferred from <code>x</code>.\nFuncAddr(imms=(func_ref: ir::FuncRef), vals=0, blocks=0)\n<code>addr = func_addr FN</code>. (FuncAddr)\n<code>a = fvdemote x</code>. (Unary)\n<code>x = fvpromote_low a</code>. (Unary)\n<code>addr = get_frame_pointer</code>. (NullAry)\n<code>addr = get_pinned_reg</code>. (NullAry)\n<code>addr = get_return_address</code>. (NullAry)\n<code>addr = get_stack_pointer</code>. (NullAry)\n<code>a = global_value GV</code>. (UnaryGlobalValue)\n<code>a = iabs x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = iadd x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = iadd_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = iadd_pairwise x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = icmp Cond, x, y</code>. (IntCompare) Type inferred from <code>x</code>.\n<code>a = icmp_imm Cond, x, Y</code>. (IntCompareImm) Type inferred …\n<code>a = iconcat lo, hi</code>. (Binary) Type inferred from <code>lo</code>.\n<code>a = iconst N</code>. (UnaryImm)\n<code>a = imul x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = imul_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\nThis is an indirect call with the specified signature. See …\n<code>a = ineg x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = insertlane x, y, Idx</code>. (TernaryImm8) Type inferred from …\nAn instruction format\nIntAddTrap(imms=(code: ir::TrapCode), vals=2, blocks=0)\nIntCompare(imms=(cond: ir::condcodes::IntCC), vals=2, …\nIntCompareImm(imms=(cond: ir::condcodes::IntCC, imm: …\n<code>a = ireduce x</code>. (Unary)\n<code>a = irsub_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = ishl x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = ishl_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>lo, hi = isplit x</code>. (Unary) Type inferred from <code>x</code>.\n<code>istore16 MemFlags, x, p, Offset</code>. (Store) Type inferred …\n<code>istore32 MemFlags, x, p, Offset</code>. (Store) Type inferred …\n<code>istore8 MemFlags, x, p, Offset</code>. (Store) Type inferred from …\n<code>a = isub x, y</code>. (Binary) Type inferred from <code>x</code>.\nJump(imms=(), vals=0, blocks=1)\n<code>jump block_call</code>. (Jump)\nLoad(imms=(flags: ir::MemFlags, offset: …\n<code>a = load MemFlags, p, Offset</code>. (Load)\nLoadNoOffset(imms=(flags: ir::MemFlags), vals=1, blocks=0)\nMultiAry(imms=(), vals=0, blocks=0)\n<code>a = nearest x</code>. (Unary) Type inferred from <code>x</code>.\n<code>nop</code>. (NullAry)\nThis is not a call instruction.\nNullAry(imms=(), vals=0, blocks=0)\nAn instruction opcode.\nValue type constraints for a given opcode.\n<code>a = popcnt x</code>. (Unary) Type inferred from <code>x</code>.\nThe type constraint on a value argument once the …\n<code>return rvals</code>. (MultiAry)\n<code>return_call FN, args</code>. (Call)\n<code>return_call_indirect SIG, callee, args</code>. (CallIndirect) …\n<code>a = rotl x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = rotl_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = rotr x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = rotr_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a, of = sadd_overflow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a, c_out = sadd_overflow_cin x, y, c_in</code>. (Ternary) Type …\n<code>a = sadd_sat x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = scalar_to_vector s</code>. (Unary)\n<code>a = sdiv x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = sdiv_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = select c, x, y</code>. (Ternary) Type inferred from <code>x</code>.\n<code>a = select_spectre_guard c, x, y</code>. (Ternary) Type inferred …\n<code>set_pinned_reg addr</code>. (Unary) Type inferred from <code>addr</code>.\n<code>a = sextend x</code>. (Unary)\nShuffle(imms=(imm: ir::Immediate), vals=2, blocks=0)\n<code>a = shuffle a, b, mask</code>. (Shuffle)\n<code>a = sload16 MemFlags, p, Offset</code>. (Load)\n<code>a = sload16x4 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = sload32 MemFlags, p, Offset</code>. (Load) Type inferred from …\n<code>a = sload32x2 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = sload8 MemFlags, p, Offset</code>. (Load)\n<code>a = sload8x8 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = smax x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = smin x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a, of = smul_overflow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = smulhi x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = snarrow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = splat x</code>. (Unary)\n<code>a = sqmul_round_sat x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = sqrt x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = srem x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = srem_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = sshr x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = sshr_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a, of = ssub_overflow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a, b_out = ssub_overflow_bin x, y, b_in</code>. (Ternary) Type …\n<code>a = ssub_sat x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>addr = stack_addr SS, Offset</code>. (StackLoad)\nStackLoad(imms=(stack_slot: ir::StackSlot, offset: …\n<code>a = stack_load SS, Offset</code>. (StackLoad)\nStackStore(imms=(stack_slot: ir::StackSlot, offset: …\n<code>stack_store x, SS, Offset</code>. (StackStore) Type inferred from …\n…\nStore(imms=(flags: ir::MemFlags, offset: …\n<code>store MemFlags, x, p, Offset</code>. (Store) Type inferred from <code>x</code>.\nStoreNoOffset(imms=(flags: ir::MemFlags), vals=2, blocks=0)\n<code>a = swiden_high x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = swiden_low x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = swizzle x, y</code>. (Binary)\n<code>a = symbol_value GV</code>. (UnaryGlobalValue)\nTernary(imms=(), vals=3, blocks=0)\nTernaryImm8(imms=(imm: ir::immediates::Uimm8), vals=2, …\n<code>a = tls_value GV</code>. (UnaryGlobalValue)\nTrap(imms=(code: ir::TrapCode), vals=0, blocks=0)\n<code>trap code</code>. (Trap)\n<code>trapnz c, code</code>. (CondTrap) Type inferred from <code>c</code>.\n<code>trapz c, code</code>. (CondTrap) Type inferred from <code>c</code>.\n<code>a = trunc x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a, of = uadd_overflow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a, c_out = uadd_overflow_cin x, y, c_in</code>. (Ternary) Type …\n<code>a = uadd_overflow_trap x, y, code</code>. (IntAddTrap) Type …\n<code>a = uadd_sat x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = udiv x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = udiv_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = uextend x</code>. (Unary)\n<code>a = uload16 MemFlags, p, Offset</code>. (Load)\n<code>a = uload16x4 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = uload32 MemFlags, p, Offset</code>. (Load) Type inferred from …\n<code>a = uload32x2 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = uload8 MemFlags, p, Offset</code>. (Load)\n<code>a = uload8x8 MemFlags, p, Offset</code>. (Load) Type inferred …\n<code>a = umax x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = umin x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a, of = umul_overflow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = umulhi x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = unarrow x, y</code>. (Binary) Type inferred from <code>x</code>.\nUnary(imms=(), vals=1, blocks=0)\nUnaryConst(imms=(constant_handle: ir::Constant), vals=0, …\nUnaryGlobalValue(imms=(global_value: ir::GlobalValue), …\nUnaryIeee16(imms=(imm: ir::immediates::Ieee16), vals=0, …\nUnaryIeee32(imms=(imm: ir::immediates::Ieee32), vals=0, …\nUnaryIeee64(imms=(imm: ir::immediates::Ieee64), vals=0, …\nUnaryImm(imms=(imm: ir::immediates::Imm64), vals=0, …\n<code>a = urem x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = urem_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a = ushr x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = ushr_imm x, Y</code>. (BinaryImm64) Type inferred from <code>x</code>.\n<code>a, of = usub_overflow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a, b_out = usub_overflow_bin x, y, b_in</code>. (Ternary) Type …\n<code>a = usub_sat x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = uunarrow x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = uwiden_high x</code>. (Unary) Type inferred from <code>x</code>.\n<code>a = uwiden_low x</code>. (Unary) Type inferred from <code>x</code>.\n<code>s = vall_true a</code>. (Unary) Type inferred from <code>a</code>.\nSome instructions use an external list of argument values …\nMemory pool for holding value lists. See <code>ValueList</code>.\nA value type set describes the permitted set of types for …\n<code>s = vany_true a</code>. (Unary) Type inferred from <code>a</code>.\nA variable list of <code>Value</code> operands used for function call …\n<code>a = vconst N</code>. (UnaryConst)\n<code>x = vhigh_bits a</code>. (Unary)\n<code>a = x86_blendv c, x, y</code>. (Ternary) Type inferred from <code>x</code>.\n<code>a = x86_cvtt2dq x</code>. (Unary)\n<code>a = x86_pmaddubsw x, y</code>. (Binary)\n<code>a = x86_pmulhrsw x, y</code>. (Binary) Type inferred from <code>x</code>.\n<code>a = x86_pshufb x, y</code>. (Binary)\nDoes <code>typ</code> belong to this set?\nGet the typeset of allowed types for the controlling type …\nAllowed dynamic vectors minimum lane sizes\nGet an example member of this type set.\nAllowed float widths\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAllowed int widths\nIs this instruction polymorphic?\nAllowed lane sizes\nGet the number of <em>fixed</em> result values produced by this …\nGet the number of <em>fixed</em> input values required by this …\nIs it necessary to look at the designated value input …\nGet the value type of result number <code>n</code>, having resolved the …\nCan the controlling type variable for this opcode be …\nGet the value type of input value number <code>n</code>, having …\nA wrapper for the context required to display a …\nContents of a jump table.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIterate over blocks in layout order. See …\nIterate over instructions in a block in layout order. See …\nThe <code>Layout</code> struct determines the layout of blocks and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAccess to a field via the wrong type.\nThe base part of a bound expression.\nA comparison result between two dynamic values with a …\nA “conflict fact”: this fact results from merging two …\nA definition of a value to be used as a symbol in …\nA pointer to a memory type, dynamically bounded. The …\nA value bounded by a global value.\nContains the error value\nA bound expression.\nA fact on a value.\nA “context” in which we can evaluate and derive facts. …\nA global value.\nThe two kinds of inequalities: “strict” (<code>&lt;</code>, <code>&gt;</code>) and “…\nAccess to an invalid or undefined field offset in a struct.\nStore of data to a field with a fact that does not subsume …\nLoose inequality: {less,greater}-than-or-equal.\nTop of the address space. This is “saturating”: the …\nA pointer to a memory type.\nAn input to an operator that produces a fact-annotated …\nNo dynamic part (i.e., zero).\nContains the success value\nA memory access is out of bounds.\nAn operation wraps around, invalidating the stated value …\nAn error or inconsistency discovered when checking …\nThe result of checking proof-carrying-code facts.\nA bitslice of a value (up to a bitwidth) is within the …\nStrict inequality: {less,greater}-than.\nProof-carrying-code checking is not implemented for a …\nProof-carrying-code checking is not implemented for a …\nA block parameter claims a fact that one of its …\nA derivation of an output fact is unsupported (incorrect or\nAn SSA Value as a symbolic value. This can be referenced in\nStore to a read-only field.\nThe dynamic (base) part.\nTop-level entry point after compilation: this checks the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe static (offset) part.\nThe bitwidth of bits we care about, from the LSB upward.\nThe bitwidth of bits we care about, from the LSB upward.\nThe kind of comparison.\nThe left-hand side of the comparison.\nThe maximum value that the bitslice can take (inclusive). …\nThe upper bound, inclusive.\nThe upper bound, inclusive.\nThe maximum offset into the memory type, inclusive.\nThe minimum value that the bitslice can take (inclusive). …\nThe lower bound, inclusive.\nThe lower bound, inclusive.\nThe minimum offset into the memory type, inclusive.\nThis pointer can also be null.\nThis pointer can also be null.\nThe right-hand side of the comparison.\nThe memory type.\nThe memory type.\nThe SSA value this value defines.\nContents of a dynamic stack slot.\nAll allocated dynamic stack slots.\nAn explicit stack slot for dynamic vector types. This is a …\nAn explicit stack slot. This is a chunk of stack memory …\nThe size of an object on the stack, or the size of a stack …\nContents of a stack slot.\nThe kind of a stack slot.\nAll allocated stack slots.\nAlignment of stack slot as a power-of-two exponent (log2 …\nThe type of this slot.\nThe kind of stack slot.\nThe kind of stack slot.\nSize of stack slot in bytes.\nA 128-bit floating point type represented in the IEEE …\nA SIMD vector with 2 lanes containing a <code>f128</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>f128</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA 16-bit floating point type represented in the IEEE …\nA SIMD vector with 16 lanes containing a <code>f16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 16 …\nA SIMD vector with 2 lanes containing a <code>f16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 32 lanes containing a <code>f16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 32 …\nA SIMD vector with 4 lanes containing a <code>f16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>f16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nA 32-bit floating point type represented in the IEEE …\nA SIMD vector with 16 lanes containing a <code>f32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 16 …\nA SIMD vector with 2 lanes containing a <code>f32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>f32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>f32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nA 64-bit floating point type represented in the IEEE …\nA SIMD vector with 2 lanes containing a <code>f64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>f64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>f64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nAn integer type with 128 bits.\nA SIMD vector with 2 lanes containing a <code>i128</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>i128</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nAn integer type with 16 bits. WARNING: arithmetic on 16bit …\nA SIMD vector with 16 lanes containing a <code>i16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 16 …\nA SIMD vector with 2 lanes containing a <code>i16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 32 lanes containing a <code>i16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 32 …\nA SIMD vector with 4 lanes containing a <code>i16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>i16</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nAn integer type with 32 bits.\nA SIMD vector with 16 lanes containing a <code>i32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 16 …\nA SIMD vector with 2 lanes containing a <code>i32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>i32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>i32</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nAn integer type with 64 bits.\nA SIMD vector with 2 lanes containing a <code>i64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 4 lanes containing a <code>i64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 8 lanes containing a <code>i64</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nAn integer type with 8 bits. WARNING: arithmetic on 8bit …\nA SIMD vector with 16 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 16 …\nA SIMD vector with 2 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 2 lanes …\nA SIMD vector with 32 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 32 …\nA SIMD vector with 4 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 4 lanes …\nA SIMD vector with 64 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 64 …\nA SIMD vector with 8 lanes containing a <code>i8</code> each.\nA dynamically-scaled SIMD vector with a minimum of 8 lanes …\nNot a valid type. Can’t be loaded or stored. Can’t be …\nThe type of an SSA value.\nThe string names of all the supported, but possibly not …\nMac aarch64 calling convention, which is a tweaked aarch64 …\nType alias of <code>IsaBuilder</code> used for building Cranelift’s …\nCalling convention identifiers.\nSmallest caller code size, not ABI-stable.\nBest performance, not ABI-stable.\nFunction alignment specifications as required by an ISA, …\nBuilder for a <code>TargetIsa</code>. Modify the ISA-specific settings …\nAfter determining that an instruction doesn’t have an …\nDescribes reason for target lookup failure\nThe type of a polymorphic TargetISA object which is ’…\nSpecialized convention for the probestack function.\nSupport for this target was disabled in the current build.\nSystem V-style convention used on many platforms.\nSupports tail calls, not ABI-stable.\nThis struct provides information that a frontend may need …\nMethods that are specialized to a target ISA.\nSupport for this target has not yet been implemented.\nThe winch calling convention, not ABI-stable.\nWindows “fastcall” convention, also used for x64 and …\nCompile the given function.\nCreates a new System V Common Information Entry for the …\nGet the default calling convention of this target.\nThe default calling convention of the target.\nGet the ISA-dependent maximum vector register size, in …\nCreates unwind information for the function.\nGet the endianness of this ISA.\nCombine the ISA-specific settings with the provided …\nGet the ISA-independent flags that were used to make this …\nReturns the calling convention used for libcalls according …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new Builder from a TargetIsa, copying all flags …\nGet the information needed by frontends producing …\nReturns the minimum function alignment and the preferred …\nReturns whether this ISA has a native …\nReturns whether the CLIF <code>x86_blendv</code> instruction is …\nReturns whether the CLIF <code>x86_pmaddubsw</code> instruction is …\nReturns whether the CLIF <code>x86_pmulhrsw</code> instruction is …\nReturns whether the CLIF <code>x86_pshufb</code> instruction is …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet a flag indicating whether branch protection is enabled.\nGet the ISA-dependent flag values that were used to make …\nIterates the available settings in the builder.\nLook for an ISA for the given <code>triple</code>. Return a builder …\nLook for a supported ISA with the given <code>name</code>. Return a …\nMap a regalloc::Reg to its corresponding DWARF register.\nThe minimum alignment required by an ISA, where all …\nGet the name of this ISA.\nCreates a new ISA-builder from its components, namely the …\nThe log2 of the target’s page size and alignment.\nThe log2 of the target’s page size and alignment.\nGet the width of pointers on this ISA, in units of bits.\nGet the width of pointers on this target, in units of bits.\nGet the width of pointers on this ISA, in units of bytes.\nGet the width of pointers on this target, in units of …\nGet the pointer type of this ISA.\nGet the pointer type of this target.\nThe pointer width of the target.\nA “preferred” alignment which should be used for more …\nDoes this calling convention support tail calls?\nReturns the minimum symbol alignment for this ISA.\nReturns an object that can be used to build the text …\nGet the target triple that was used to make this trait …\nGets the triple for the builder.\nReturn the default calling convention for the given target …\nRepresents information relating to function unwinding.\nCreate a polymorphic TargetIsa from this specific …\nX86_64-bit Instruction Set Architecture.\nDefines if the aarch64-specific pointer authentication …\nCFA-based unwind information used on SystemV.\nThe frame-pointer register for this architecture has just …\nNo unwind info.\nThe frame-pointer register for this architecture has just …\nComputes the value of the given register in the caller as …\nThe stack slot at the given offset from the clobber-area …\nThe stack pointer was adjusted to allocate the stack.\nSystemV CIE/FDE unwind info.\nSystem V ABI unwind information.\nRepresents unwind information for a single function.\nExpected unwind info type.\nUnwind pseudoinstruction used in VCode backends: …\nWindows X64 Unwind info\nWindows Arm64 ABI unwind information.\nWindows x64 ABI unwind information.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSystem V ABI unwind information.\nWindows Arm64 ABI unwind information.\nWindows x64 ABI unwind information.\nThe offset from the start of the clobber area to this …\nThe offset from the start of the clobber area to this …\nThe offset from the current SP and FP value downward to …\nThe offset from the current SP (after push) to the SP at …\nThe offset from the current SP and FP value upward to the …\nThe saved register.\nThe register whose value is to be set.\nWhether return addresses (hold in LR) contain a …\nSize to allocate.\nEnumerate the errors possible in mapping Cranelift …\nRepresents unwind information for a single System V ABI …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts the unwind information into a …\nRepresents Windows Arm64 unwind information.\nCalculate the number of words needed to encode the unwind …\nEmits the unwind information into the given mutable byte …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRepresents Windows x64 unwind information.\nEmits the unwind information into the given mutable byte …\nGets the emit size of the unwind information, in bytes.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nConstant state used during emissions of a sequence of …\nState carried between emissions of a sequence of …\nInternal type MInst: defined at src/isa/x64/inst.isle line …\nInstruction operand sub-components (aka “parts”): …\nCreates a new x86-64 common information entry (CIE).\nEmit unwind info for an x86 target.\nContains the encoding machinery for the various x64 …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a constant state for emission of instructions.\nx86 Settings.\nAdd with carry.\nAdd operation.\nInternal type AluRmROpcode: defined at …\nSome basic ALU operations.\nInternal type Amode: defined at src/isa/x64/inst.isle line …\nBitwise AND operation.\nInternal type Avx512Opcode: defined at …\nInternal type AvxOpcode: defined at src/isa/x64/inst.isle …\n&lt; unsigned\n&lt;= unsigned\nByte -&gt; Longword.\nByte -&gt; Quadword.\nBit-scan forward.\nBit-scan reverse.\nThese indicate condition code tests.  Not all are …\nCMP instruction: compute <code>a - b</code> and set flags from result.\nComparison operations.\nA virtual offset to a constant that will be emitted in the …\nInternal type DivSignedness: defined at …\nEqual comparison.\nThis defines the ways a value can be extended: either …\nThese indicate ways of extending (widening) a value, using …\nEncode the ways that floats can be compared. This is used …\nAn x64 memory fence kind.\nAn extension trait for converting <code>Writable&lt;Reg&gt;</code> to …\nA newtype wrapper around <code>Reg</code>.\nA newtype wrapper around <code>RegMem</code> for general-purpose …\nA newtype wrapper around <code>RegMemImm</code>.\nAn immediate operand.\n8-bit immediate operand.\nA newtype wrapper around <code>Imm8Reg</code>.\nAn operand which is either an 8-bit integer immediate or a …\nA newtype wrapper around <code>Imm8Reg</code>.\nA (virtual) offset into the incoming argument area.\n&lt; signed\n&lt;= signed\n<code>lfence</code> instruction (“Load Fence”)\nLongword -&gt; Quadword.\nLess than comparison.\nLess than or equal comparison.\nCounts leading zeroes (Leading Zero CouNT).\n<code>mfence</code> instruction (“Memory Fence”)\nA memory operand.\nA memory operand.\n= unsigned\nunsigned\n= signed\nsigned\nno overflow\nnot parity\nnot-negative\nnot-zero\nNo value.\nNo value.\nNo extension.\nNot equal comparison.\noverflow\nAn operand’s size in bits.\nOptional writable Gpr.\nOptional writable Gpr.\nBitwise inclusive OR.\nOrdered.\nparity\nCounts the number of ones (POPulation CouNT).\nA real amode.\nA register operand.\nA register operand.\nA register operand.\nAn operand which is either an integer Register or a value …\nAn operand which is either an integer Register, a value in …\nLeft rotation.\nRight rotation.\nRound down mode.\nEncode the rounding modes used as part of the Rounding …\nRound to nearest mode.\nRound up mode.\nRound to zero mode.\nnegative\n<code>sfence</code> instruction (“Store Fence”)\nInteger subtraction with borrow.\nThese indicate the form of a scalar shift/rotate: left, …\nLeft shift.\nReplicates the sign bit in the most significant bits.\nInserts zeros in the most significant bits.\nSign-extend.\n16-bit.\n32-bit.\n64-bit.\n8-bit.\nA (virtual) offset to the slot area of the function frame, …\nSome value of type <code>T</code>.\nSome value of type <code>T</code>.\nSome SSE operations requiring 2 operands r/m and r.\nInteger subtraction.\nA Memory Address. These denote a 64-bit value only. Used …\nTEST instruction: compute <code>a &amp; b</code> and set flags from result.\nAn extension trait for converting <code>Writable{Xmm,Gpr}</code> to …\nCounts trailing zeroes (Trailing Zero CouNT).\nInternal type UnaryRmRImmVexOpcode: defined at …\nUnary operations requiring register or memory and register …\nInternal type UnaryRmRVexOpcode: defined at …\nUnordered.\nUnordered or greater than comparison.\nUnordered of greater than or equal comparison.\nWord -&gt; Longword.\nWord -&gt; Quadword.\nWritable Gpr.\nWritable Gpr.\nA newtype wrapper around <code>Reg</code>.\nA newtype wrapper around <code>RegMem</code> for general-purpose …\nA newtype wrapper around <code>RegMem</code> for general-purpose …\nA newtype wrapper around <code>RegMemImm</code>.\nA newtype wrapper around <code>RegMemImm</code>.\nBitwise exclusive OR.\nzero\nZero-extend.\nBorrow this newtype as its underlying <code>Imm8Reg</code>.\nBorrow this newtype as its underlying <code>Imm8Reg</code>.\nBorrow this newtype as its underlying <code>Imm8Reg</code>.\nBorrow this newtype as its underlying <code>Imm8Reg</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert <code>Writable&lt;Reg&gt;</code> to <code>Writable{Xmm,Gpr}</code>.\nCreate an immediate operand.\nCreate an immediate sign-extended and register addressing …\nCreate a sign-extended-32-to-64 with register and shift …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a memory operand.\nCreate a memory operand.\nCreate this newtype from the given register, or return <code>None</code>…\nConstruct a <code>RegMem</code> newtype from the given <code>RegMem</code>, or return\nConstruct this newtype from the given <code>RegMemImm</code>, or return …\nConstruct this newtype from the given <code>Imm8Reg</code>, or return …\nCreate this newtype from the given register, or return <code>None</code>…\nConstruct a <code>RegMem</code> newtype from the given <code>RegMem</code>, or return\nConstruct a <code>RegMem</code> newtype from the given <code>RegMem</code>, or return\nConstruct this newtype from the given <code>RegMemImm</code>, or return …\nConstruct this newtype from the given <code>RegMemImm</code>, or return …\nConstruct this newtype from the given <code>Imm8Reg</code>, or return …\nCreate a real addressing mode.\nCreate a register operand.\nCreate a register operand.\nGet this newtype’s underlying <code>Reg</code>.\nGet this newtype’s underlying <code>Reg</code>.\nConvert this newtype into its underlying <code>RegMem</code>.\nConvert this newtype into its underlying <code>RegMem</code>.\nConvert this newtype into its underlying <code>RegMem</code>.\nConvert this newtype into its underlying <code>RegMemImm</code>.\nConvert this newtype into its underlying <code>RegMemImm</code>.\nConvert this newtype into its underlying <code>RegMemImm</code>.\nConvert <code>Writable{Xmm,Gpr}</code> to <code>Writable&lt;Reg&gt;</code>.\nWhat is the “TupleType” of this opcode, which affects …\nLike <code>Self::new(r).unwrap()</code> but with a better panic message …\nLike <code>Self::new(rm).unwrap()</code> but with better panic messages …\nLike <code>Self::new(rmi).unwrap()</code> but with better panic …\nLike <code>Self::new(imm8_reg).unwrap()</code> but with better panic …\nLike <code>Self::new(r).unwrap()</code> but with a better panic message …\nLike <code>Self::new(rm).unwrap()</code> but with better panic messages …\nLike <code>Self::new(rm).unwrap()</code> but with better panic messages …\nLike <code>Self::new(rmi).unwrap()</code> but with better panic …\nLike <code>Self::new(rmi).unwrap()</code> but with better panic …\nLike <code>Self::new(imm8_reg).unwrap()</code> but with better panic …\nSet the specified MemFlags to the Amode.\nThe 8-bit immediate value.\nThe underlying register.\nThe memory address.\nThe underlying register.\nThe memory address.\nThe underlying register.\nThe immediate value.\nThe downward offset from the start of the incoming …\nThe offset into the slot area.\nThe encoding formats in this module all require a way of …\nEncodes EVEX instructions. These instructions are those …\nAdd 1 byte to the code section.\nAdd 2 bytes to the code section.\nAdd 4 bytes to the code section.\nAdd 8 bytes to the code section.\nEncodes instructions in the standard x86 encoding mode. …\nEncodes VEX instructions. These instructions are those …\nDefines the EVEX context for the <code>L&#39;</code>, <code>L</code>, and <code>b</code> bits (bits …\nConstructs an EVEX-encoded instruction using a builder …\nDefines the EVEX masking behavior; masking support is …\nThe EVEX format allows defining rounding control in the <code>L&#39;</code> …\nThe EVEX format allows choosing a vector length in the <code>L&#39;</code> …\nDescribe the register index to use. This wrapper is a …\nEncode the <code>aaa</code> bits for merging with the P2 byte.\nEncode the <code>L&#39;</code>, <code>L</code>, and <code>b</code> bits (bits 6:4 of EVEX P2 byte) …\nEmit the EVEX-encoded instruction to the code sink:\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSet the imm byte.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSet the length of the instruction . Note that there are …\nSet the opcode map byte of the instruction: None | 0F | …\nSet the mask to use. See section 2.6 in the Intel Software …\nConstruct a default EVEX instruction.\nSet the instruction opcode byte.\nSet the legacy prefix byte of the instruction: None | 66 | …\nSet the register to use for the <code>reg</code> bits; many …\nSet the register to use for the <code>rm</code> bits; many instructions …\nSet the “tuple type” which is used for 8-bit scaling …\nSet the <code>vvvvv</code> register; some instructions allow using this …\nSet the W bit, typically used to indicate an instruction …\nEncode the <code>z</code> bit for merging with the P2 byte.\nWe may need to include one or more legacy prefix bytes …\nNo prefix bytes.\nAllows using the same opcode byte in different “opcode …\nA small bit field to record a REX prefix specification:\nOperand Size Override – here, denoting “16-bit …\nOperand size override and Lock.\nOperand size override and same effect as F3.\nThe Lock prefix.\nREPNE, but no specific meaning here – is just an opcode …\nREP/REPE, but no specific meaning here – is just an …\nRequire that the REX prefix is emitted.\nEmit the rex prefix if the referenced register would …\nCreates a new RexPrefix for which the REX.W bit will be …\nEmit a unary instruction.\nEmit a ternary instruction.\nEmit a binary instruction.\nEncode the ModR/M byte.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if the REX prefix must always be emitted.\nTrue if 64-bit operands are used.\nBy default, set the W field, and don’t always emit.\nConstructs a VEX-encoded instruction using a builder …\nThe VEX format allows choosing a vector length in the <code>L</code> …\nEmit the VEX-encoded instruction to the provided buffer.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSet the imm byte. Overrides a previously set Self::imm_reg …\nSet the imm byte when used for a register. The reg bits …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSet the length of the instruction.\nSet the opcode map byte of the instruction: None | 0F | …\nConstruct a default VEX instruction.\nSet the instruction opcode byte.\nSome instructions use the ModRM.reg field as an opcode …\nSet the legacy prefix byte of the instruction: None | 66 | …\nSet the register to use for the <code>reg</code> bits; many …\nSet the register to use for the <code>rm</code> bits; many instructions …\nSet the <code>vvvv</code> register; some instructions allow using this …\nSet the W bit, denoted by <code>.W1</code> or <code>.W0</code> in the instruction …\nFlags group <code>x86</code>.\nCreate a <code>settings::Builder</code> for the x86 settings group.\nReturns the argument unchanged.\nHas support for AVX. AVX: CPUID.01H:ECX.AVX[bit 28]\nHas support for AVX2. AVX2: CPUID.07H:EBX.AVX2[bit 5]\nHas support for AVX512BITALG. AVX512BITALG: …\nHas support for AVX512DQ. AVX512DQ: CPUID.07H:EBX.AVX512DQ[…\nHas support for AVX512F. AVX512F: CPUID.07H:EBX.AVX512F[…\nHas support for AVX512VMBI. AVX512VBMI: …\nHas support for AVX512VL. AVX512VL: CPUID.07H:EBX.AVX512VL[…\nHas support for BMI1. BMI1: CPUID.(EAX=07H, …\nHas support for BMI2. BMI2: CPUID.(EAX=07H, …\nHas support for CMPXCHG16b. CMPXCHG16b: …\nHas support for FMA. FMA: CPUID.01H:ECX.FMA[bit 12]\nHas support for LZCNT. LZCNT: CPUID.EAX=80000001H:ECX.LZCNT…\nHas support for POPCNT. POPCNT: CPUID.01H:ECX.POPCNT[bit 23…\nHas support for SSE3. SSE3: CPUID.01H:ECX.SSE3[bit 0]\nHas support for SSE4.1. SSE4.1: CPUID.01H:ECX.SSE4_1[bit 19…\nHas support for SSE4.2. SSE4.2: CPUID.01H:ECX.SSE4_2[bit 20…\nHas support for SSSE3. SSSE3: CPUID.01H:ECX.SSSE3[bit 9]\nCalls <code>U::from(self)</code>.\nIterates the setting values.\nCreate flags x86 settings group.\nGet a view of the boolean predicates.\nComputed predicate <code>x86.has_avx()</code>.\nComputed predicate <code>x86.has_avx() &amp;&amp; x86.has_avx2()</code>.\nComputed predicate <code>x86.has_avx512bitalg()</code>.\nComputed predicate <code>x86.has_avx512dq()</code>.\nComputed predicate <code>x86.has_avx512f()</code>.\nComputed predicate <code>x86.has_avx512vbmi()</code>.\nComputed predicate <code>x86.has_avx512vl()</code>.\nComputed predicate <code>x86.has_bmi1()</code>.\nComputed predicate <code>x86.has_bmi2()</code>.\nComputed predicate <code>x86.has_cmpxchg16b()</code>.\nComputed predicate <code>x86.has_avx() &amp;&amp; x86.has_fma()</code>.\nComputed predicate <code>x86.has_lzcnt()</code>.\nComputed predicate <code>x86.has_popcnt() &amp;&amp; x86.has_sse42()</code>.\nComputed predicate <code>x86.has_sse41()</code>.\nComputed predicate <code>x86.has_sse41() &amp;&amp; x86.has_sse42()</code>.\nComputed predicate <code>x86.has_ssse3()</code>.\nA opaque reference to a code loop.\nLoop tree information for a single function.\nA level in a loop nest.\nReturn the raw bit encoding for this instance.\nReturn the underlying index value as a <code>u32</code>.\nA clamped loop level from a larger-width (usize) depth.\nClear all the data structures contained in the loop …\nDetects the loops in a function. Needs the control flow …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new instance from the raw bit encoding.\nCreate a new instance from a <code>u32</code>.\nOne loop level deeper.\nReturn the innermost loop for a given block.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInvalid loop level.\nDetermines if a loop is contained in another loop.\nDetermine if a Block belongs to a loop by running a finger …\nDetermine if a Block is a loop header. If so, return the …\nCheck if the loop analysis is in a valid state.\nGet the loop level.\nReturns the header block of a particular loop.\nReturns the loop-nest level of a given block.\nReturn the eventual parent of a loop in the loop tree.\nReturns all the loops contained in a function.\nAllocate a new blank loop analysis struct. Use <code>compute</code> to …\nGet the root level (no loop).\nPretty-print a Cranelift error.\nPretty-print a verifier error.\n<code>apple_aarch64</code>.\n<code>backtracking</code>.\nNo setting by this name exists.\nType mismatch for setting (e.g., setting an enum setting …\nThis is not a valid value for this setting.\n<code>basic</code>.\nThe setting is a boolean.\nCollect settings values based on a template.\n<code>coff</code>.\n<code>cold</code>.\nA string-based configurator for settings groups.\n<code>elf_gd</code>.\nThe setting is an enumeration.\nContains the error value\n<code>fast</code>.\nFlags group <code>shared</code>.\nWrapper containing flags and optionally a <code>TargetIsa</code> trait …\n<code>inline</code>.\n<code>isa_default</code>.\nValues for <code>shared.libcall_call_conv</code>.\n<code>macho</code>.\n<code>none</code>.\n<code>none</code>.\n<code>none</code>.\nThe setting is a number.\nContains the success value\nValues for <code>shared.opt_level</code>.\n<code>outline</code>.\nA reference to just the boolean predicates of a settings …\nThe setting is a preset.\n<code>probestack</code>.\nValues for <code>shared.probestack_strategy</code>.\nValues for <code>shared.regalloc_algorithm</code>.\nAn error produced when changing a setting.\nA result returned when changing a setting.\nRepresents an available builder setting.\nRepresents the kind of setting.\n<code>single_pass</code>.\n<code>speed</code>.\n<code>speed_and_size</code>.\nValues for <code>shared.stack_switch_model</code>.\n<code>system_v</code>.\nValues for <code>shared.tls_model</code>.\n<code>update_windows_tib</code>.\nRepresents a setting value.\n<code>windows_fastcall</code>.\nReturns a slice with all possible RegallocAlgorithm values.\nReturns a slice with all possible OptLevel values.\nReturns a slice with all possible TlsModel values.\nReturns a slice with all possible StackSwitchModel values.\nReturns a slice with all possible LibcallCallConv values.\nReturns a slice with all possible ProbestackStrategy …\nGets the boolean value if the value is from a boolean …\nGets the enum value if the value is from an enum setting.\nGets the numerical value if the value is from a num …\nThe log2 of the size to insert dummy padding between basic …\nCreate a <code>settings::Builder</code> for the shared settings group.\nThe description of the setting.\nImplementation details for generated code.\nEnable a boolean setting or apply a preset.\nDo redundant-load optimizations with alias analysis.\nEnable the use of atomic instructions\nEnable the use of floating-point instructions.\nEnable Spectre mitigation on heap bounds checks.\nEnable additional checks for debugging the incremental …\nEnable the use of jump tables in generated machine code.\nEnable various ABI extensions defined by LLVM’s behavior.\nEnable support for sret arg introduction when there are …\nEnable NaN canonicalization.\nEnable proof-carrying code translation validation.\nEnable the use of the pinned register.\nEnable the use of stack probes for supported calling …\nEnable safepoint instruction insertions.\nEnable Spectre mitigation on table bounds checks.\nRun the Cranelift IR verifier at strategic times during …\nFlags are always present.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEnable Position-Independent Code generation.\nThe ISA may not be present.\nIterates the available settings in the builder.\nIterates the setting values.\nGets the kind of setting.\nThe kind of the setting.\nDefines the calling convention to use for LibCalls call …\nGenerate CFG metadata for machine code.\nThe name of the setting associated with this value.\nThe name of the setting.\nCreate a new builder with defaults and names from the …\nCreate a new view of a precomputed predicate vector.\nCreate flags shared settings group.\nOptimization level for generated code.\nGet a view of the boolean predicates.\nPreserve frame pointers\nThe log2 of the size of the stack guard region.\nControls what kinds of stack probes are emitted.\nAlgorithm to use in register allocator.\nEnable the symbolic checker for register allocation.\nEnable verbose debug logs for regalloc2.\nSet the string value of any setting by name.\nDefines the model used to performing stack switching.\nExtract contents of builder once everything is configured.\nCheck a numbered predicate.\nDefines the model used to perform TLS accesses.\nGenerate unwind information.\nUse colocated libcalls.\nBuilds a string from the current value\nThe supported values of the setting (for enum values).\nA boolean setting only uses one bit, numbered from LSB.\nA setting descriptor holds the information needed to …\nThe different kind of settings along with descriptor bits …\nAn Enum setting uses a range of enumerators.\nA numerical setting uses the whole byte.\nA preset is not an individual setting, it is a collection …\nAn instruction group template.\nDefault values.\nThe description of the setting.\nList of setting descriptors.\nAdditional details, depending on the kind of setting.\nUnion of all enumerators.\nGet enumerators corresponding to a <code>Details::Enum</code>.\nFormat a setting value as a TOML string. This is mostly …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHash table of settings.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if a detail is a Detail::Preset. Useful because the …\nName of the instruction group.\nLower snake-case name of setting as defined in meta.\nOffset of byte containing this setting.\nPairs of (mask, value) for presets.\n0-7.\nFirst enumerator in the ENUMERATORS table.\nNumerical value of last enumerator, allowing for 1-256 …\nThe default profiler. You can get the results using …\nThe amount of profiled passes.\nNo active pass.\nA single profiled pass.\nAccumulated timing for all passes.\nA profiler.\nAdd <code>other</code> to the timings of this <code>PassTimes</code>.\nCanonicalization of NaNs\nCanonicalization of NaNs\nCompilation passes\nCompilation passes\nDescription of the pass.\nDominator tree\nDominator tree\nEgraph based optimizations\nEgraph based optimizations\nControl flow graph\nControl flow graph\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGlobal value numbering\nGlobal value numbering\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLayout full renumbering\nLayout full renumbering\nLoop invariant code motion\nLoop invariant code motion\nLoop analysis\nLoop analysis\nParsing textual Cranelift IR\nParsing textual Cranelift IR\nPre-legalization rewriting\nPre-legalization rewriting\nProcessing test file\nProcessing test file\nRegister allocation\nRegister allocation\nRegister allocation symbolic verification\nRegister allocation symbolic verification\nRemove constant phi-nodes\nRemove constant phi-nodes\nSet the profiler for the current thread.\nStart a profiling pass.\nStore in incremental cache\nStore in incremental cache\nTake the current accumulated pass timings and reset the …\nReturns the total amount of time taken by all the passes …\nTry loading from incremental cache\nTry loading from incremental cache\nRemove unreachable blocks\nRemove unreachable blocks\nVCode emission\nVCode emission\nVCode emission finalization\nVCode emission finalization\nVCode lowering\nVCode lowering\nVerify Cranelift IR\nVerify Cranelift IR\nTranslate WASM function\nTranslate WASM function\nTranslate WASM module\nTranslate WASM module\nA depth-first traversal.\nAn iterator that yields pairs of <code>(Event, ir::Block)</code> items …\nAn iterator that yields <code>ir::Block</code> items during a …\nAn iterator that yields <code>ir::Block</code> items during a …\nEntering traversal of a block.\nA low-level DFS traversal event: either entering or …\nExiting traversal of a block.\nClear this DFS, but keep its allocations for future reuse.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.")